# This file was automatically generated by SWIG (http://www.swig.org).
# Version 1.3.36
#
# Don't modify this file, modify the SWIG interface instead.

import _algorithms
import new
new_instancemethod = new.instancemethod
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'PySwigObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static) or hasattr(self,name):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError,name

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

import types
try:
    _object = types.ObjectType
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0
del types


def _swig_setattr_nondynamic_method(set):
    def set_attr(self,name,value):
        if (name == "thisown"): return self.this.own(value)
        if hasattr(self,name) or (name == "this"):
            set(self,name,value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


# ----------------------------------------------------------------------
# Numenta Platform for Intelligent Computing (NuPIC)
# Copyright (C) 2013, Numenta, Inc.  Unless you have purchased from
# Numenta, Inc. a separate commercial license for this software code, the
# following terms and conditions apply:
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License version 3 as
# published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see http://www.gnu.org/licenses.
#
# http://numenta.org/licenses/
# ----------------------------------------------------------------------

import os

_ALGORITHMS = _algorithms


def forceRetentionOfFDRCSpatialInfer(*args):
  """forceRetentionOfFDRCSpatialInfer()"""
  return _algorithms.forceRetentionOfFDRCSpatialInfer(*args)

def forceRetentionOfGaborComputeWithinLibrary(*args):
  """forceRetentionOfGaborComputeWithinLibrary()"""
  return _algorithms.forceRetentionOfGaborComputeWithinLibrary(*args)

def forceRetentionOfImageSensorLiteLibrary(*args):
  """forceRetentionOfImageSensorLiteLibrary()"""
  return _algorithms.forceRetentionOfImageSensorLiteLibrary(*args)
class feature_node(object):
    """Proxy of C++ feature_node class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    index = _swig_property(_algorithms.feature_node_index_get, _algorithms.feature_node_index_set)
    value = _swig_property(_algorithms.feature_node_value_get, _algorithms.feature_node_value_set)
    def __init__(self, *args, **kwargs): 
        """__init__(self) -> feature_node"""
        this = _algorithms.new_feature_node(*args, **kwargs)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _algorithms.delete_feature_node
feature_node_swigregister = _algorithms.feature_node_swigregister
feature_node_swigregister(feature_node)

class sparse_feature_vector(object):
    """Proxy of C++ sparse_feature_vector class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    data = _swig_property(_algorithms.sparse_feature_vector_data_get, _algorithms.sparse_feature_vector_data_set)
    def __init__(self, *args): 
        """
        __init__(self) -> sparse_feature_vector
        __init__(self, n, dense_array) -> sparse_feature_vector
        """
        this = _algorithms.new_sparse_feature_vector(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _algorithms.delete_sparse_feature_vector
sparse_feature_vector_swigregister = _algorithms.sparse_feature_vector_swigregister
sparse_feature_vector_swigregister(sparse_feature_vector)

class problem(object):
    """Proxy of C++ problem class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args, **kwargs): 
        """__init__(self, l_, n_, bias_) -> problem"""
        this = _algorithms.new_problem(*args, **kwargs)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _algorithms.delete_problem
    l = _swig_property(_algorithms.problem_l_get, _algorithms.problem_l_set)
    n = _swig_property(_algorithms.problem_n_get, _algorithms.problem_n_set)
    bias = _swig_property(_algorithms.problem_bias_get, _algorithms.problem_bias_set)
    y = _swig_property(_algorithms.problem_y_get, _algorithms.problem_y_set)
    x = _swig_property(_algorithms.problem_x_get, _algorithms.problem_x_set)
problem_swigregister = _algorithms.problem_swigregister
problem_swigregister(problem)

L2_LR = _algorithms.L2_LR
L1_LR = _algorithms.L1_LR
L2LOSS_SVM = _algorithms.L2LOSS_SVM
class parameter(object):
    """Proxy of C++ parameter class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> parameter
        __init__(self, solver_type_, eps_, C_, nr_weight_=0, weight_label_=None, 
            weight_=None) -> parameter
        """
        this = _algorithms.new_parameter(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _algorithms.delete_parameter
    solver_type = _swig_property(_algorithms.parameter_solver_type_get, _algorithms.parameter_solver_type_set)
    eps = _swig_property(_algorithms.parameter_eps_get, _algorithms.parameter_eps_set)
    C = _swig_property(_algorithms.parameter_C_get, _algorithms.parameter_C_set)
    nr_weight = _swig_property(_algorithms.parameter_nr_weight_get, _algorithms.parameter_nr_weight_set)
    weight_label = _swig_property(_algorithms.parameter_weight_label_get, _algorithms.parameter_weight_label_set)
    weight = _swig_property(_algorithms.parameter_weight_get, _algorithms.parameter_weight_set)
parameter_swigregister = _algorithms.parameter_swigregister
parameter_swigregister(parameter)

class model(object):
    """Proxy of C++ model class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args, **kwargs): 
        """__init__(self) -> model"""
        this = _algorithms.new_model(*args, **kwargs)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _algorithms.delete_model
    def get_labels(*args, **kwargs):
        """get_labels(self, label)"""
        return _algorithms.model_get_labels(*args, **kwargs)

    param = _swig_property(_algorithms.model_param_get, _algorithms.model_param_set)
    nr_class = _swig_property(_algorithms.model_nr_class_get, _algorithms.model_nr_class_set)
    nr_feature = _swig_property(_algorithms.model_nr_feature_get, _algorithms.model_nr_feature_set)
    w = _swig_property(_algorithms.model_w_get, _algorithms.model_w_set)
    label = _swig_property(_algorithms.model_label_get, _algorithms.model_label_set)
    bias = _swig_property(_algorithms.model_bias_get, _algorithms.model_bias_set)
model_swigregister = _algorithms.model_swigregister
model_swigregister(model)

class function(object):
    """Proxy of C++ function class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError, "No constructor defined"
    __repr__ = _swig_repr
    def fun(*args, **kwargs):
        """fun(self, w) -> float"""
        return _algorithms.function_fun(*args, **kwargs)

    def grad(*args, **kwargs):
        """grad(self, w, g)"""
        return _algorithms.function_grad(*args, **kwargs)

    def Hv(*args, **kwargs):
        """Hv(self, s, Hs)"""
        return _algorithms.function_Hv(*args, **kwargs)

    def get_nr_variable(*args, **kwargs):
        """get_nr_variable(self) -> int"""
        return _algorithms.function_get_nr_variable(*args, **kwargs)

    __swig_destroy__ = _algorithms.delete_function
function_swigregister = _algorithms.function_swigregister
function_swigregister(function)

class TRON(object):
    """Proxy of C++ TRON class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args, **kwargs): 
        """__init__(self, fun_obj, eps=0.1, max_iter=1000) -> TRON"""
        this = _algorithms.new_TRON(*args, **kwargs)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _algorithms.delete_TRON
    def tron(*args, **kwargs):
        """tron(self, w)"""
        return _algorithms.TRON_tron(*args, **kwargs)

TRON_swigregister = _algorithms.TRON_swigregister
TRON_swigregister(TRON)

class linear(object):
    """Proxy of C++ linear class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args, **kwargs): 
        """
        __init__(self, solver_type, eps, C, nr_weight=0, weight_label=None, 
            weight=None) -> linear
        """
        this = _algorithms.new_linear(*args, **kwargs)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _algorithms.delete_linear
    x_space = _swig_property(_algorithms.linear_x_space_get, _algorithms.linear_x_space_set)
    the_param = _swig_property(_algorithms.linear_the_param_get, _algorithms.linear_the_param_set)
    the_problem = _swig_property(_algorithms.linear_the_problem_get, _algorithms.linear_the_problem_set)
    the_model = _swig_property(_algorithms.linear_the_model_get, _algorithms.linear_the_model_set)
    def train(*args, **kwargs):
        """train(self)"""
        return _algorithms.linear_train(*args, **kwargs)

    def save_model(*args, **kwargs):
        """save_model(self, model_file_name) -> int"""
        return _algorithms.linear_save_model(*args, **kwargs)

    def load_model(*args, **kwargs):
        """load_model(self, model_file_name)"""
        return _algorithms.linear_load_model(*args, **kwargs)

    def create_problem(*args):
        """
        create_problem(self, l, n, y, x, bias=-1.0)
        create_problem(self, size, n_dims, labelsIn, samplesIn, bias=-1.0)
        """
        return _algorithms.linear_create_problem(*args)

    def cross_validation(*args):
        """
        cross_validation(self, nr_fold, target)
        cross_validation(self, nr_fold, py_target)
        """
        return _algorithms.linear_cross_validation(*args)

    def predict_values(*args):
        """
        predict_values(self, x, dec_values) -> int
        predict_values(self, py_x, py_dec_values) -> int
        """
        return _algorithms.linear_predict_values(*args)

    def predict(*args):
        """
        predict(self, x) -> int
        predict(self, py_x) -> int
        """
        return _algorithms.linear_predict(*args)

    def predict_probability(*args):
        """
        predict_probability(self, x, prob_estimates) -> int
        predict_probability(self, py_x, py_prob_estimates) -> int
        """
        return _algorithms.linear_predict_probability(*args)

linear_swigregister = _algorithms.linear_swigregister
linear_swigregister(linear)

class svm_problem(object):
    """Proxy of C++ svm_problem class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    recover_ = _swig_property(_algorithms.svm_problem_recover__get, _algorithms.svm_problem_recover__set)
    n_dims_ = _swig_property(_algorithms.svm_problem_n_dims__get, _algorithms.svm_problem_n_dims__set)
    x_ = _swig_property(_algorithms.svm_problem_x__get, _algorithms.svm_problem_x__set)
    y_ = _swig_property(_algorithms.svm_problem_y__get, _algorithms.svm_problem_y__set)
    def __init__(self, *args): 
        """
        __init__(self, n_dims, recover, ?=0) -> svm_problem
        __init__(self, n_dims, size, recover, ?=0) -> svm_problem
        __init__(self, inStream) -> svm_problem
        """
        this = _algorithms.new_svm_problem(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _algorithms.delete_svm_problem
    def size(*args, **kwargs):
        """size(self) -> int"""
        return _algorithms.svm_problem_size(*args, **kwargs)

    def n_dims(*args, **kwargs):
        """n_dims(self) -> int"""
        return _algorithms.svm_problem_n_dims(*args, **kwargs)

    def nnz(*args, **kwargs):
        """nnz(self, i) -> int"""
        return _algorithms.svm_problem_nnz(*args, **kwargs)

    def resize(*args, **kwargs):
        """resize(self, n)"""
        return _algorithms.svm_problem_resize(*args, **kwargs)

    def set_sample(*args, **kwargs):
        """set_sample(self, i, s)"""
        return _algorithms.svm_problem_set_sample(*args, **kwargs)

    def get_sample(*args, **kwargs):
        """get_sample(self, i) -> sample_type"""
        return _algorithms.svm_problem_get_sample(*args, **kwargs)

    def dense(*args, **kwargs):
        """dense(self, i, sv)"""
        return _algorithms.svm_problem_dense(*args, **kwargs)

    def persistent_size(*args, **kwargs):
        """persistent_size(self) -> int"""
        return _algorithms.svm_problem_persistent_size(*args, **kwargs)

    def save(*args, **kwargs):
        """save(self, outStream)"""
        return _algorithms.svm_problem_save(*args, **kwargs)

    def load(*args, **kwargs):
        """load(self, inStream)"""
        return _algorithms.svm_problem_load(*args, **kwargs)

    def get_samples(*args, **kwargs):
        """get_samples(self, samplesIn)"""
        return _algorithms.svm_problem_get_samples(*args, **kwargs)

svm_problem_swigregister = _algorithms.svm_problem_swigregister
svm_problem_swigregister(svm_problem)

class svm_problem01(object):
    """Proxy of C++ svm_problem01 class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    recover_ = _swig_property(_algorithms.svm_problem01_recover__get, _algorithms.svm_problem01_recover__set)
    n_dims_ = _swig_property(_algorithms.svm_problem01_n_dims__get, _algorithms.svm_problem01_n_dims__set)
    threshold_ = _swig_property(_algorithms.svm_problem01_threshold__get, _algorithms.svm_problem01_threshold__set)
    nnz_ = _swig_property(_algorithms.svm_problem01_nnz__get, _algorithms.svm_problem01_nnz__set)
    x_ = _swig_property(_algorithms.svm_problem01_x__get, _algorithms.svm_problem01_x__set)
    y_ = _swig_property(_algorithms.svm_problem01_y__get, _algorithms.svm_problem01_y__set)
    buf_ = _swig_property(_algorithms.svm_problem01_buf__get, _algorithms.svm_problem01_buf__set)
    def __init__(self, *args): 
        """
        __init__(self, n_dims, recover, threshold=.9) -> svm_problem01
        __init__(self, n_dims, size, recover, threshold=.9) -> svm_problem01
        __init__(self, inStream) -> svm_problem01
        """
        this = _algorithms.new_svm_problem01(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _algorithms.delete_svm_problem01
    def size(*args, **kwargs):
        """size(self) -> int"""
        return _algorithms.svm_problem01_size(*args, **kwargs)

    def n_dims(*args, **kwargs):
        """n_dims(self) -> int"""
        return _algorithms.svm_problem01_n_dims(*args, **kwargs)

    def nnz(*args, **kwargs):
        """nnz(self, i) -> int"""
        return _algorithms.svm_problem01_nnz(*args, **kwargs)

    def resize(*args, **kwargs):
        """resize(self, n)"""
        return _algorithms.svm_problem01_resize(*args, **kwargs)

    def set_sample(*args, **kwargs):
        """set_sample(self, i, s)"""
        return _algorithms.svm_problem01_set_sample(*args, **kwargs)

    def get_sample(*args, **kwargs):
        """get_sample(self, i) -> sample_type"""
        return _algorithms.svm_problem01_get_sample(*args, **kwargs)

    def dense(*args, **kwargs):
        """dense(self, i, sv)"""
        return _algorithms.svm_problem01_dense(*args, **kwargs)

    def persistent_size(*args, **kwargs):
        """persistent_size(self) -> int"""
        return _algorithms.svm_problem01_persistent_size(*args, **kwargs)

    def save(*args, **kwargs):
        """save(self, outStream)"""
        return _algorithms.svm_problem01_save(*args, **kwargs)

    def load(*args, **kwargs):
        """load(self, inStream)"""
        return _algorithms.svm_problem01_load(*args, **kwargs)

    def get_samples(*args, **kwargs):
        """get_samples(self, samplesIn)"""
        return _algorithms.svm_problem01_get_samples(*args, **kwargs)

svm_problem01_swigregister = _algorithms.svm_problem01_swigregister
svm_problem01_swigregister(svm_problem01)

class decision_function(object):
    """Proxy of C++ decision_function class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args, **kwargs): 
        """__init__(self) -> decision_function"""
        this = _algorithms.new_decision_function(*args, **kwargs)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _algorithms.delete_decision_function
    alpha = _swig_property(_algorithms.decision_function_alpha_get, _algorithms.decision_function_alpha_set)
    rho = _swig_property(_algorithms.decision_function_rho_get, _algorithms.decision_function_rho_set)
decision_function_swigregister = _algorithms.decision_function_swigregister
decision_function_swigregister(decision_function)

class svm_model(object):
    """Proxy of C++ svm_model class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    n_dims_ = _swig_property(_algorithms.svm_model_n_dims__get, _algorithms.svm_model_n_dims__set)
    sv_mem = _swig_property(_algorithms.svm_model_sv_mem_get, _algorithms.svm_model_sv_mem_set)
    sv = _swig_property(_algorithms.svm_model_sv_get, _algorithms.svm_model_sv_set)
    sv_coef = _swig_property(_algorithms.svm_model_sv_coef_get, _algorithms.svm_model_sv_coef_set)
    rho = _swig_property(_algorithms.svm_model_rho_get, _algorithms.svm_model_rho_set)
    label = _swig_property(_algorithms.svm_model_label_get, _algorithms.svm_model_label_set)
    n_sv = _swig_property(_algorithms.svm_model_n_sv_get, _algorithms.svm_model_n_sv_set)
    probA = _swig_property(_algorithms.svm_model_probA_get, _algorithms.svm_model_probA_set)
    probB = _swig_property(_algorithms.svm_model_probB_get, _algorithms.svm_model_probB_set)
    w = _swig_property(_algorithms.svm_model_w_get, _algorithms.svm_model_w_set)
    def size(*args, **kwargs):
        """size(self) -> int"""
        return _algorithms.svm_model_size(*args, **kwargs)

    def n_dims(*args, **kwargs):
        """n_dims(self) -> int"""
        return _algorithms.svm_model_n_dims(*args, **kwargs)

    def n_class(*args, **kwargs):
        """n_class(self) -> int"""
        return _algorithms.svm_model_n_class(*args, **kwargs)

    def __init__(self, *args, **kwargs): 
        """__init__(self) -> svm_model"""
        this = _algorithms.new_svm_model(*args, **kwargs)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _algorithms.delete_svm_model
    def persistent_size(*args, **kwargs):
        """persistent_size(self) -> int"""
        return _algorithms.svm_model_persistent_size(*args, **kwargs)

    def save(*args, **kwargs):
        """save(self, outStream)"""
        return _algorithms.svm_model_save(*args, **kwargs)

    def load(*args, **kwargs):
        """load(self, inStream)"""
        return _algorithms.svm_model_load(*args, **kwargs)

    def get_support_vectors(*args, **kwargs):
        """get_support_vectors(self, svIn)"""
        return _algorithms.svm_model_get_support_vectors(*args, **kwargs)

    def get_support_vector_coefficients(*args, **kwargs):
        """get_support_vector_coefficients(self, svCoeffIn)"""
        return _algorithms.svm_model_get_support_vector_coefficients(*args, **kwargs)

    def get_hyperplanes(*args, **kwargs):
        """get_hyperplanes(self) -> PyObject"""
        return _algorithms.svm_model_get_hyperplanes(*args, **kwargs)

svm_model_swigregister = _algorithms.svm_model_swigregister
svm_model_swigregister(svm_model)

class QMatrix(object):
    """Proxy of C++ QMatrix class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args, **kwargs): 
        """__init__(self, prob, g, kernel, cache_size) -> QMatrix"""
        this = _algorithms.new_QMatrix(*args, **kwargs)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _algorithms.delete_QMatrix
    def get_Q(*args, **kwargs):
        """get_Q(self, i, len) -> float"""
        return _algorithms.QMatrix_get_Q(*args, **kwargs)

    def get_QD(*args, **kwargs):
        """get_QD(self) -> float"""
        return _algorithms.QMatrix_get_QD(*args, **kwargs)

    def swap_index(*args, **kwargs):
        """swap_index(self, i, j)"""
        return _algorithms.QMatrix_swap_index(*args, **kwargs)

    def dot(*args, **kwargs):
        """dot(self, i, j) -> feature_type"""
        return _algorithms.QMatrix_dot(*args, **kwargs)

    def linear_kernel(*args, **kwargs):
        """linear_kernel(self, i, j) -> float"""
        return _algorithms.QMatrix_linear_kernel(*args, **kwargs)

    def rbf_kernel(*args, **kwargs):
        """rbf_kernel(self, i, j) -> float"""
        return _algorithms.QMatrix_rbf_kernel(*args, **kwargs)

QMatrix_swigregister = _algorithms.QMatrix_swigregister
QMatrix_swigregister(QMatrix)

class QMatrix01(object):
    """Proxy of C++ QMatrix01 class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args, **kwargs): 
        """__init__(self, prob, g, kernel, cache_size) -> QMatrix01"""
        this = _algorithms.new_QMatrix01(*args, **kwargs)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _algorithms.delete_QMatrix01
    def get_Q(*args, **kwargs):
        """get_Q(self, i, len) -> float"""
        return _algorithms.QMatrix01_get_Q(*args, **kwargs)

    def get_QD(*args, **kwargs):
        """get_QD(self) -> float"""
        return _algorithms.QMatrix01_get_QD(*args, **kwargs)

    def swap_index(*args, **kwargs):
        """swap_index(self, i, j)"""
        return _algorithms.QMatrix01_swap_index(*args, **kwargs)

    def dot(*args, **kwargs):
        """dot(self, i, j) -> feature_type"""
        return _algorithms.QMatrix01_dot(*args, **kwargs)

    def linear_kernel(*args, **kwargs):
        """linear_kernel(self, i, j) -> float"""
        return _algorithms.QMatrix01_linear_kernel(*args, **kwargs)

    def rbf_kernel(*args, **kwargs):
        """rbf_kernel(self, i, j) -> float"""
        return _algorithms.QMatrix01_rbf_kernel(*args, **kwargs)

QMatrix01_swigregister = _algorithms.QMatrix01_swigregister
QMatrix01_swigregister(QMatrix01)

class svm_parameter(object):
    """Proxy of C++ svm_parameter class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args, **kwargs): 
        """__init__(self, k, p, g, c, e, cs, s) -> svm_parameter"""
        this = _algorithms.new_svm_parameter(*args, **kwargs)
        try: self.this.append(this)
        except: self.this = this
    kernel = _swig_property(_algorithms.svm_parameter_kernel_get, _algorithms.svm_parameter_kernel_set)
    probability = _swig_property(_algorithms.svm_parameter_probability_get, _algorithms.svm_parameter_probability_set)
    gamma = _swig_property(_algorithms.svm_parameter_gamma_get, _algorithms.svm_parameter_gamma_set)
    C = _swig_property(_algorithms.svm_parameter_C_get, _algorithms.svm_parameter_C_set)
    eps = _swig_property(_algorithms.svm_parameter_eps_get, _algorithms.svm_parameter_eps_set)
    cache_size = _swig_property(_algorithms.svm_parameter_cache_size_get, _algorithms.svm_parameter_cache_size_set)
    shrinking = _swig_property(_algorithms.svm_parameter_shrinking_get, _algorithms.svm_parameter_shrinking_set)
    weight_label = _swig_property(_algorithms.svm_parameter_weight_label_get, _algorithms.svm_parameter_weight_label_set)
    weight = _swig_property(_algorithms.svm_parameter_weight_get, _algorithms.svm_parameter_weight_set)
    def persistent_size(*args, **kwargs):
        """persistent_size(self) -> int"""
        return _algorithms.svm_parameter_persistent_size(*args, **kwargs)

    def save(*args, **kwargs):
        """save(self, outStream)"""
        return _algorithms.svm_parameter_save(*args, **kwargs)

    def load(*args, **kwargs):
        """load(self, inStream)"""
        return _algorithms.svm_parameter_load(*args, **kwargs)

    __swig_destroy__ = _algorithms.delete_svm_parameter
svm_parameter_swigregister = _algorithms.svm_parameter_swigregister
svm_parameter_swigregister(svm_parameter)

class svm_std_traits(object):
    """Proxy of C++ svm_std_traits class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args, **kwargs): 
        """__init__(self) -> svm_std_traits"""
        this = _algorithms.new_svm_std_traits(*args, **kwargs)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _algorithms.delete_svm_std_traits
svm_std_traits_swigregister = _algorithms.svm_std_traits_swigregister
svm_std_traits_swigregister(svm_std_traits)

class svm_01_traits(object):
    """Proxy of C++ svm_01_traits class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args, **kwargs): 
        """__init__(self) -> svm_01_traits"""
        this = _algorithms.new_svm_01_traits(*args, **kwargs)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _algorithms.delete_svm_01_traits
svm_01_traits_swigregister = _algorithms.svm_01_traits_swigregister
svm_01_traits_swigregister(svm_01_traits)

class svm_dense(object):
    """Proxy of C++ svm_dense class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args, **kwargs): 
        """
        __init__(self, kernel=0, n_dims=0, threshold=.9, cache_size=100, shrinking=1, 
            probability=False, seed=-1) -> svm_dense
        """
        this = _algorithms.new_svm_dense(*args, **kwargs)
        try: self.this.append(this)
        except: self.this = this
    def train(*args, **kwargs):
        """train(self, gamma, C, eps)"""
        return _algorithms.svm_dense_train(*args, **kwargs)

    def get_problem(*args, **kwargs):
        """get_problem(self) -> svm_problem"""
        return _algorithms.svm_dense_get_problem(*args, **kwargs)

    def get_model(*args, **kwargs):
        """get_model(self) -> svm_model"""
        return _algorithms.svm_dense_get_model(*args, **kwargs)

    def discard_problem(*args, **kwargs):
        """discard_problem(self)"""
        return _algorithms.svm_dense_discard_problem(*args, **kwargs)

    def cross_validation(*args, **kwargs):
        """cross_validation(self, n_fold, gamma, C, eps) -> float"""
        return _algorithms.svm_dense_cross_validation(*args, **kwargs)

    def persistent_size(*args, **kwargs):
        """persistent_size(self) -> int"""
        return _algorithms.svm_dense_persistent_size(*args, **kwargs)

    def __getstate__(*args, **kwargs):
        """__getstate__(self) -> PyObject"""
        return _algorithms.svm_dense___getstate__(*args, **kwargs)

    def __init__(self, *args, **kwargs):
      """
      __init__(self, kernel=0, n_dims=0, threshold=.9, cache_size=100, shrinking=1,
        probability=False, seed=-1) -> svm_dense

      nta::algorithms::svm::svm_dense::svm_dense(int kernel=0, int n_dims=0,
      float threshold=.9, int cache_size=100, int shrinking=1, bool
      probability=false)
      """
      # Convert numpy ints to regular ints for Python 2.6
      for k in ('kernel', 'n_dims', 'cache_size', 'shrinking'):
          if k in kwargs:
            kwargs[k] = int(kwargs[k])

      this = _ALGORITHMS.new_svm_dense(*args, **kwargs)
      try: self.this.append(this)
      except: self.this = this

    def __setstate__(self, inString):
      self.this = _ALGORITHMS.new_svm_dense()
      self.thisown = 1
      self.loadFromString(inString)
      
    def loadFromString(*args, **kwargs):
        """loadFromString(self, inString)"""
        return _algorithms.svm_dense_loadFromString(*args, **kwargs)

    def add_sample(*args, **kwargs):
        """add_sample(self, y_val, x_vector)"""
        return _algorithms.svm_dense_add_sample(*args, **kwargs)

    def predict(*args, **kwargs):
        """predict(self, x_vector) -> float"""
        return _algorithms.svm_dense_predict(*args, **kwargs)

    def predict_probability(*args, **kwargs):
        """predict_probability(self, x_vector, proba_vector) -> float"""
        return _algorithms.svm_dense_predict_probability(*args, **kwargs)

    def save(*args):
        """
        save(self, outStream)
        save(self, filename)
        """
        return _algorithms.svm_dense_save(*args)

    def load(*args):
        """
        load(self, inStream)
        load(self, filename)
        """
        return _algorithms.svm_dense_load(*args)

    def cross_validate(*args, **kwargs):
        """cross_validate(self, n_fold, gamma, C, eps) -> float"""
        return _algorithms.svm_dense_cross_validate(*args, **kwargs)

    def trainReleaseGIL(*args, **kwargs):
        """trainReleaseGIL(self, gamma, C, eps)"""
        return _algorithms.svm_dense_trainReleaseGIL(*args, **kwargs)

    __swig_destroy__ = _algorithms.delete_svm_dense
svm_dense_swigregister = _algorithms.svm_dense_swigregister
svm_dense_swigregister(svm_dense)

class svm_01(object):
    """Proxy of C++ svm_01 class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args, **kwargs): 
        """
        __init__(self, kernel=0, n_dims=0, threshold=.9, cache_size=100, shrinking=1, 
            probability=False, seed=-1) -> svm_01
        """
        this = _algorithms.new_svm_01(*args, **kwargs)
        try: self.this.append(this)
        except: self.this = this
    def train(*args, **kwargs):
        """train(self, gamma, C, eps)"""
        return _algorithms.svm_01_train(*args, **kwargs)

    def get_problem(*args, **kwargs):
        """get_problem(self) -> svm_problem01"""
        return _algorithms.svm_01_get_problem(*args, **kwargs)

    def get_model(*args, **kwargs):
        """get_model(self) -> svm_model"""
        return _algorithms.svm_01_get_model(*args, **kwargs)

    def discard_problem(*args, **kwargs):
        """discard_problem(self)"""
        return _algorithms.svm_01_discard_problem(*args, **kwargs)

    def cross_validation(*args, **kwargs):
        """cross_validation(self, n_fold, gamma, C, eps) -> float"""
        return _algorithms.svm_01_cross_validation(*args, **kwargs)

    def persistent_size(*args, **kwargs):
        """persistent_size(self) -> int"""
        return _algorithms.svm_01_persistent_size(*args, **kwargs)

    def __getstate__(*args, **kwargs):
        """__getstate__(self) -> PyObject"""
        return _algorithms.svm_01___getstate__(*args, **kwargs)

    def __setstate__(self, inString):
      self.this = _ALGORITHMS.new_svm_01()
      self.thisown = 1
      self.loadFromString(inString)
      
    def loadFromString(*args, **kwargs):
        """loadFromString(self, inString)"""
        return _algorithms.svm_01_loadFromString(*args, **kwargs)

    def add_sample(*args, **kwargs):
        """add_sample(self, y_val, x_vector)"""
        return _algorithms.svm_01_add_sample(*args, **kwargs)

    def predict(*args, **kwargs):
        """predict(self, x_vector) -> float"""
        return _algorithms.svm_01_predict(*args, **kwargs)

    def predict_probability(*args, **kwargs):
        """predict_probability(self, x_vector, proba_vector) -> float"""
        return _algorithms.svm_01_predict_probability(*args, **kwargs)

    def cross_validate(*args, **kwargs):
        """cross_validate(self, n_fold, gamma, C, eps) -> float"""
        return _algorithms.svm_01_cross_validate(*args, **kwargs)

    def trainReleaseGIL(*args, **kwargs):
        """trainReleaseGIL(self, gamma, C, eps)"""
        return _algorithms.svm_01_trainReleaseGIL(*args, **kwargs)

    def save(*args):
        """
        save(self, outStream)
        save(self, filename)
        """
        return _algorithms.svm_01_save(*args)

    def load(*args):
        """
        load(self, inStream)
        load(self, filename)
        """
        return _algorithms.svm_01_load(*args)

    __swig_destroy__ = _algorithms.delete_svm_01
svm_01_swigregister = _algorithms.svm_01_swigregister
svm_01_swigregister(svm_01)

class Float32SeparableConvolution2D(object):
    """Proxy of C++ Float32SeparableConvolution2D class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    nrows_ = _swig_property(_algorithms.Float32SeparableConvolution2D_nrows__get, _algorithms.Float32SeparableConvolution2D_nrows__set)
    ncols_ = _swig_property(_algorithms.Float32SeparableConvolution2D_ncols__get, _algorithms.Float32SeparableConvolution2D_ncols__set)
    f1_size_ = _swig_property(_algorithms.Float32SeparableConvolution2D_f1_size__get, _algorithms.Float32SeparableConvolution2D_f1_size__set)
    f2_size_ = _swig_property(_algorithms.Float32SeparableConvolution2D_f2_size__get, _algorithms.Float32SeparableConvolution2D_f2_size__set)
    f1_end_j_ = _swig_property(_algorithms.Float32SeparableConvolution2D_f1_end_j__get, _algorithms.Float32SeparableConvolution2D_f1_end_j__set)
    f2_end_i_ = _swig_property(_algorithms.Float32SeparableConvolution2D_f2_end_i__get, _algorithms.Float32SeparableConvolution2D_f2_end_i__set)
    f1_middle_ = _swig_property(_algorithms.Float32SeparableConvolution2D_f1_middle__get, _algorithms.Float32SeparableConvolution2D_f1_middle__set)
    f2_middle_ = _swig_property(_algorithms.Float32SeparableConvolution2D_f2_middle__get, _algorithms.Float32SeparableConvolution2D_f2_middle__set)
    f1_ = _swig_property(_algorithms.Float32SeparableConvolution2D_f1__get, _algorithms.Float32SeparableConvolution2D_f1__set)
    f2_ = _swig_property(_algorithms.Float32SeparableConvolution2D_f2__get, _algorithms.Float32SeparableConvolution2D_f2__set)
    f1_end_ = _swig_property(_algorithms.Float32SeparableConvolution2D_f1_end__get, _algorithms.Float32SeparableConvolution2D_f1_end__set)
    f2_end_ = _swig_property(_algorithms.Float32SeparableConvolution2D_f2_end__get, _algorithms.Float32SeparableConvolution2D_f2_end__set)
    buffer_ = _swig_property(_algorithms.Float32SeparableConvolution2D_buffer__get, _algorithms.Float32SeparableConvolution2D_buffer__set)
    def __init__(self, *args, **kwargs): 
        """__init__(self) -> Float32SeparableConvolution2D"""
        this = _algorithms.new_Float32SeparableConvolution2D(*args, **kwargs)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _algorithms.delete_Float32SeparableConvolution2D
    def init(*args):
        """
        init(self, nrows, ncols, f1_size, f2_size, f1, f2)
        init(self, nrows, ncols, f1_size, f2_size, pyF1, pyF2)
        """
        return _algorithms.Float32SeparableConvolution2D_init(*args)

    def compute(*args):
        """
        compute(self, data, convolved, rotated45=False)
        compute(self, pyData, pyConvolved, rotated45=False)
        """
        return _algorithms.Float32SeparableConvolution2D_compute(*args)

    def getBuffer(*args, **kwargs):
        """getBuffer(self, pyBuffer)"""
        return _algorithms.Float32SeparableConvolution2D_getBuffer(*args, **kwargs)

Float32SeparableConvolution2D_swigregister = _algorithms.Float32SeparableConvolution2D_swigregister
Float32SeparableConvolution2D_swigregister(Float32SeparableConvolution2D)

cos45 = _algorithms.cos45
class Float32Rotation45(object):
    """Proxy of C++ Float32Rotation45 class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    srow_ = _swig_property(_algorithms.Float32Rotation45_srow__get, _algorithms.Float32Rotation45_srow__set)
    scol_ = _swig_property(_algorithms.Float32Rotation45_scol__get, _algorithms.Float32Rotation45_scol__set)
    offset_ = _swig_property(_algorithms.Float32Rotation45_offset__get, _algorithms.Float32Rotation45_offset__set)
    def round(*args, **kwargs):
        """round(self, x) -> float"""
        return _algorithms.Float32Rotation45_round(*args, **kwargs)

    def rotate(*args):
        """
        rotate(self, original, rotated, nrows, ncols, z)
        rotate(self, pyOriginal, pyRotated, nrows, ncols, z)
        """
        return _algorithms.Float32Rotation45_rotate(*args)

    def unrotate(*args):
        """
        unrotate(self, unrotated, rotated, nrows, ncols, z)
        unrotate(self, pyUnrotated, pyRotated, nrows, ncols, z)
        """
        return _algorithms.Float32Rotation45_unrotate(*args)

    def __init__(self, *args, **kwargs): 
        """__init__(self) -> Float32Rotation45"""
        this = _algorithms.new_Float32Rotation45(*args, **kwargs)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _algorithms.delete_Float32Rotation45
Float32Rotation45_swigregister = _algorithms.Float32Rotation45_swigregister
Float32Rotation45_swigregister(Float32Rotation45)

class Float32Erosion(object):
    """Proxy of C++ Float32Erosion class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    nrows_ = _swig_property(_algorithms.Float32Erosion_nrows__get, _algorithms.Float32Erosion_nrows__set)
    ncols_ = _swig_property(_algorithms.Float32Erosion_ncols__get, _algorithms.Float32Erosion_ncols__set)
    buffer_ = _swig_property(_algorithms.Float32Erosion_buffer__get, _algorithms.Float32Erosion_buffer__set)
    def __init__(self, *args, **kwargs): 
        """__init__(self) -> Float32Erosion"""
        this = _algorithms.new_Float32Erosion(*args, **kwargs)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _algorithms.delete_Float32Erosion
    def init(*args):
        """
        init(self, nrows, ncols)
        init(self, nrows, ncols)
        """
        return _algorithms.Float32Erosion_init(*args)

    def compute(*args):
        """
        compute(self, data, eroded, iterations, dilate=False)
        compute(self, pyData, pyEroded, iterations, dilate=False)
        """
        return _algorithms.Float32Erosion_compute(*args)

    def getBuffer(*args, **kwargs):
        """getBuffer(self, pyBuffer)"""
        return _algorithms.Float32Erosion_getBuffer(*args, **kwargs)

Float32Erosion_swigregister = _algorithms.Float32Erosion_swigregister
Float32Erosion_swigregister(Float32Erosion)

class SparsePoolerInputMasks(object):
    """Proxy of C++ SparsePoolerInputMasks class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args): 
        """
        __init__(self) -> SparsePoolerInputMasks
        __init__(self, ss, masks) -> SparsePoolerInputMasks
        __init__(self, inStream) -> SparsePoolerInputMasks
        """
        this = _algorithms.new_SparsePoolerInputMasks(*args)
        try: self.this.append(this)
        except: self.this = this
    def nMasks(*args, **kwargs):
        """nMasks(self) -> size_t"""
        return _algorithms.SparsePoolerInputMasks_nMasks(*args, **kwargs)

    def empty(*args, **kwargs):
        """empty(self) -> bool"""
        return _algorithms.SparsePoolerInputMasks_empty(*args, **kwargs)

    def segmentSize(*args, **kwargs):
        """segmentSize(self) -> size_type"""
        return _algorithms.SparsePoolerInputMasks_segmentSize(*args, **kwargs)

    def minSize(*args, **kwargs):
        """minSize(self) -> size_type"""
        return _algorithms.SparsePoolerInputMasks_minSize(*args, **kwargs)

    def maxSize(*args, **kwargs):
        """maxSize(self) -> size_type"""
        return _algorithms.SparsePoolerInputMasks_maxSize(*args, **kwargs)

    def size(*args, **kwargs):
        """size(self, i) -> size_type"""
        return _algorithms.SparsePoolerInputMasks_size(*args, **kwargs)

    def mask(*args, **kwargs):
        """mask(self, i) -> Mask"""
        return _algorithms.SparsePoolerInputMasks_mask(*args, **kwargs)

    def ratio(*args, **kwargs):
        """ratio(self, i) -> value_type"""
        return _algorithms.SparsePoolerInputMasks_ratio(*args, **kwargs)

    def saveState(*args, **kwargs):
        """saveState(self, outStream)"""
        return _algorithms.SparsePoolerInputMasks_saveState(*args, **kwargs)

    def readState(*args, **kwargs):
        """readState(self, inStream)"""
        return _algorithms.SparsePoolerInputMasks_readState(*args, **kwargs)

    def __getstate__(*args, **kwargs):
        """__getstate__(self) -> string"""
        return _algorithms.SparsePoolerInputMasks___getstate__(*args, **kwargs)

    def __setstate__(self, inString):
      self.this = _ALGORITHMS.new_SparsePoolerInputMasks()
      self.thisown = 1
      self.load(inString)

    def load(*args, **kwargs):
        """load(self, inString)"""
        return _algorithms.SparsePoolerInputMasks_load(*args, **kwargs)

    def __str__(*args, **kwargs):
        """__str__(self) -> string"""
        return _algorithms.SparsePoolerInputMasks___str__(*args, **kwargs)

    def __repr__(*args, **kwargs):
        """__repr__(self) -> string"""
        return _algorithms.SparsePoolerInputMasks___repr__(*args, **kwargs)

    __swig_destroy__ = _algorithms.delete_SparsePoolerInputMasks
SparsePoolerInputMasks_swigregister = _algorithms.SparsePoolerInputMasks_swigregister
SparsePoolerInputMasks_swigregister(SparsePoolerInputMasks)

def computeAlpha(*args):
  """
    computeAlpha(xstep, ystep, widthS, heightS, imageWidth, imageHeight, 
        xcount, ycount, weightWidth, sharpness, 
        data, values, counts, weights)
    computeAlpha(xstep, ystep, widthS, heightS, imageWidth, imageHeight, 
        xcount, ycount, weightWidth, sharpness, 
        pyData, pyValues, pyCounts, pyWeights)
    """
  return _algorithms.computeAlpha(*args)

class SparsePooler(object):
    """Proxy of C++ SparsePooler class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    none = _algorithms.SparsePooler_none
    kWinners = _algorithms.SparsePooler_kWinners
    threshold = _algorithms.SparsePooler_threshold
    gaussian = _algorithms.SparsePooler_gaussian
    dot = _algorithms.SparsePooler_dot
    product = _algorithms.SparsePooler_product
    kthroot_product = _algorithms.SparsePooler_kthroot_product
    def convertSparsificationMode(*args):
        """
        convertSparsificationMode(name) -> SparsificationMode
        convertSparsificationMode(mode) -> string
        """
        return _algorithms.SparsePooler_convertSparsificationMode(*args)

    convertSparsificationMode = staticmethod(convertSparsificationMode)
    def convertInferenceMode(*args):
        """
        convertInferenceMode(name) -> InferenceMode
        convertInferenceMode(mode) -> string
        """
        return _algorithms.SparsePooler_convertInferenceMode(*args)

    convertInferenceMode = staticmethod(convertInferenceMode)
    def __init__(self, *args): 
        """
        __init__(self) -> SparsePooler
        __init__(self, inputMasks, normalize, norm, sparsification_mode, inference_mode, 
            kWinners, threshold, min_accept_distance, 
            min_accept_norm, min_proto_sum, sigma, 
            seed=0) -> SparsePooler
        __init__(self, inStream, seed=0) -> SparsePooler
        """
        this = _algorithms.new_SparsePooler(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _algorithms.delete_SparsePooler
    def saveState(*args, **kwargs):
        """saveState(self, outStream)"""
        return _algorithms.SparsePooler_saveState(*args, **kwargs)

    def readState(*args, **kwargs):
        """readState(self, inStream)"""
        return _algorithms.SparsePooler_readState(*args, **kwargs)

    def setDoNormalization(*args, **kwargs):
        """setDoNormalization(self, flag)"""
        return _algorithms.SparsePooler_setDoNormalization(*args, **kwargs)

    def getDoNormalization(*args, **kwargs):
        """getDoNormalization(self) -> size_type"""
        return _algorithms.SparsePooler_getDoNormalization(*args, **kwargs)

    def setNorm(*args, **kwargs):
        """setNorm(self, lp)"""
        return _algorithms.SparsePooler_setNorm(*args, **kwargs)

    def getNorm(*args, **kwargs):
        """getNorm(self) -> value_type"""
        return _algorithms.SparsePooler_getNorm(*args, **kwargs)

    def setSparsificationMode(*args, **kwargs):
        """setSparsificationMode(self, mode)"""
        return _algorithms.SparsePooler_setSparsificationMode(*args, **kwargs)

    def getSparsificationMode(*args, **kwargs):
        """getSparsificationMode(self) -> size_type"""
        return _algorithms.SparsePooler_getSparsificationMode(*args, **kwargs)

    def getSparsificationModeStr(*args, **kwargs):
        """getSparsificationModeStr(self) -> string"""
        return _algorithms.SparsePooler_getSparsificationModeStr(*args, **kwargs)

    def setKWinners(*args, **kwargs):
        """setKWinners(self, kWinners)"""
        return _algorithms.SparsePooler_setKWinners(*args, **kwargs)

    def getKWinners(*args, **kwargs):
        """getKWinners(self) -> size_type"""
        return _algorithms.SparsePooler_getKWinners(*args, **kwargs)

    def setThreshold(*args, **kwargs):
        """setThreshold(self, threshold)"""
        return _algorithms.SparsePooler_setThreshold(*args, **kwargs)

    def getThreshold(*args, **kwargs):
        """getThreshold(self) -> value_type"""
        return _algorithms.SparsePooler_getThreshold(*args, **kwargs)

    def setMinAcceptDistance(*args, **kwargs):
        """setMinAcceptDistance(self, d)"""
        return _algorithms.SparsePooler_setMinAcceptDistance(*args, **kwargs)

    def getMinAcceptDistance(*args, **kwargs):
        """getMinAcceptDistance(self) -> value_type"""
        return _algorithms.SparsePooler_getMinAcceptDistance(*args, **kwargs)

    def setMinAcceptNorm(*args, **kwargs):
        """setMinAcceptNorm(self, d)"""
        return _algorithms.SparsePooler_setMinAcceptNorm(*args, **kwargs)

    def getMinAcceptNorm(*args, **kwargs):
        """getMinAcceptNorm(self) -> value_type"""
        return _algorithms.SparsePooler_getMinAcceptNorm(*args, **kwargs)

    def setMinProtoSum(*args, **kwargs):
        """setMinProtoSum(self, x)"""
        return _algorithms.SparsePooler_setMinProtoSum(*args, **kwargs)

    def getMinProtoSum(*args, **kwargs):
        """getMinProtoSum(self) -> value_type"""
        return _algorithms.SparsePooler_getMinProtoSum(*args, **kwargs)

    def setInferenceMode(*args, **kwargs):
        """setInferenceMode(self, mode)"""
        return _algorithms.SparsePooler_setInferenceMode(*args, **kwargs)

    def getInferenceMode(*args, **kwargs):
        """getInferenceMode(self) -> size_type"""
        return _algorithms.SparsePooler_getInferenceMode(*args, **kwargs)

    def getInferenceModeStr(*args, **kwargs):
        """getInferenceModeStr(self) -> string"""
        return _algorithms.SparsePooler_getInferenceModeStr(*args, **kwargs)

    def setSigma(*args, **kwargs):
        """setSigma(self, s)"""
        return _algorithms.SparsePooler_setSigma(*args, **kwargs)

    def getSigma(*args, **kwargs):
        """getSigma(self) -> value_type"""
        return _algorithms.SparsePooler_getSigma(*args, **kwargs)

    def getCurrentSparsePoolerVersion(*args, **kwargs):
        """getCurrentSparsePoolerVersion(self) -> string"""
        return _algorithms.SparsePooler_getCurrentSparsePoolerVersion(*args, **kwargs)

    def getSegmentSize(*args, **kwargs):
        """getSegmentSize(self) -> size_type"""
        return _algorithms.SparsePooler_getSegmentSize(*args, **kwargs)

    def getInputMasks(*args):
        """
        getInputMasks(self) -> SparsePoolerInputMasks
        getInputMasks(self) -> SparsePoolerInputMasks
        """
        return _algorithms.SparsePooler_getInputMasks(*args)

    def setInputMasks(*args, **kwargs):
        """setInputMasks(self, masks)"""
        return _algorithms.SparsePooler_setInputMasks(*args, **kwargs)

    def getTotalNPrototypes(*args, **kwargs):
        """getTotalNPrototypes(self) -> size_type"""
        return _algorithms.SparsePooler_getTotalNPrototypes(*args, **kwargs)

    def getNPrototypeSizes(*args, **kwargs):
        """getNPrototypeSizes(self) -> size_t"""
        return _algorithms.SparsePooler_getNPrototypeSizes(*args, **kwargs)

    def getNPrototypes(*args, **kwargs):
        """getNPrototypes(self, i) -> size_type"""
        return _algorithms.SparsePooler_getNPrototypes(*args, **kwargs)

    def getPrototypes(*args, **kwargs):
        """getPrototypes(self, i) -> Prototypes"""
        return _algorithms.SparsePooler_getPrototypes(*args, **kwargs)

    def getCoincidenceMatrixHandle(*args, **kwargs):
        """getCoincidenceMatrixHandle(self) -> SM"""
        return _algorithms.SparsePooler_getCoincidenceMatrixHandle(*args, **kwargs)

    def getCoincidenceMatrix(*args, **kwargs):
        """getCoincidenceMatrix(self, buf, dense=False)"""
        return _algorithms.SparsePooler_getCoincidenceMatrix(*args, **kwargs)

    def setRNGSeed(*args, **kwargs):
        """setRNGSeed(self, seed)"""
        return _algorithms.SparsePooler_setRNGSeed(*args, **kwargs)

    def learn(*args, **kwargs):
        """learn(self, py_x) -> PyObject"""
        return _algorithms.SparsePooler_learn(*args, **kwargs)

    def infer(*args, **kwargs):
        """infer(self, py_x) -> PyObject"""
        return _algorithms.SparsePooler_infer(*args, **kwargs)

    def __getstate__(*args, **kwargs):
        """__getstate__(self) -> string"""
        return _algorithms.SparsePooler___getstate__(*args, **kwargs)

    def __setstate__(self, inString):
      self.this = _ALGORITHMS.new_SparsePooler()
      self.thisown = 1
      self.load(inString)

    def load(*args, **kwargs):
        """load(self, inString)"""
        return _algorithms.SparsePooler_load(*args, **kwargs)

    def prototypes(*args, **kwargs):
        """prototypes(self, i) -> PyObject"""
        return _algorithms.SparsePooler_prototypes(*args, **kwargs)

    def __str__(*args, **kwargs):
        """__str__(self) -> string"""
        return _algorithms.SparsePooler___str__(*args, **kwargs)

    def __repr__(*args, **kwargs):
        """__repr__(self) -> string"""
        return _algorithms.SparsePooler___repr__(*args, **kwargs)

SparsePooler_swigregister = _algorithms.SparsePooler_swigregister
SparsePooler_swigregister(SparsePooler)

def SparsePooler_convertSparsificationMode(*args):
  """
    convertSparsificationMode(name) -> SparsificationMode
    SparsePooler_convertSparsificationMode(mode) -> string
    """
  return _algorithms.SparsePooler_convertSparsificationMode(*args)

def SparsePooler_convertInferenceMode(*args):
  """
    convertInferenceMode(name) -> InferenceMode
    SparsePooler_convertInferenceMode(mode) -> string
    """
  return _algorithms.SparsePooler_convertInferenceMode(*args)

class Byte_Vector(object):
    """Proxy of C++ Byte_Vector class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def iterator(*args, **kwargs):
        """iterator(self, PYTHON_SELF) -> PySwigIterator"""
        return _algorithms.Byte_Vector_iterator(*args, **kwargs)

    def __iter__(self): return self.iterator()
    def __nonzero__(*args, **kwargs):
        """__nonzero__(self) -> bool"""
        return _algorithms.Byte_Vector___nonzero__(*args, **kwargs)

    def __len__(*args, **kwargs):
        """__len__(self) -> std::vector<(char)>::size_type"""
        return _algorithms.Byte_Vector___len__(*args, **kwargs)

    def pop(*args, **kwargs):
        """pop(self) -> std::vector<(char)>::value_type"""
        return _algorithms.Byte_Vector_pop(*args, **kwargs)

    def __getslice__(*args, **kwargs):
        """__getslice__(self, i, j) -> Byte_Vector"""
        return _algorithms.Byte_Vector___getslice__(*args, **kwargs)

    def __setslice__(*args, **kwargs):
        """__setslice__(self, i, j, v)"""
        return _algorithms.Byte_Vector___setslice__(*args, **kwargs)

    def __delslice__(*args, **kwargs):
        """__delslice__(self, i, j)"""
        return _algorithms.Byte_Vector___delslice__(*args, **kwargs)

    def __delitem__(*args, **kwargs):
        """__delitem__(self, i)"""
        return _algorithms.Byte_Vector___delitem__(*args, **kwargs)

    def __getitem__(*args, **kwargs):
        """__getitem__(self, i) -> std::vector<(char)>::value_type"""
        return _algorithms.Byte_Vector___getitem__(*args, **kwargs)

    def __setitem__(*args, **kwargs):
        """__setitem__(self, i, x)"""
        return _algorithms.Byte_Vector___setitem__(*args, **kwargs)

    def append(*args, **kwargs):
        """append(self, x)"""
        return _algorithms.Byte_Vector_append(*args, **kwargs)

    def empty(*args, **kwargs):
        """empty(self) -> bool"""
        return _algorithms.Byte_Vector_empty(*args, **kwargs)

    def size(*args, **kwargs):
        """size(self) -> std::vector<(char)>::size_type"""
        return _algorithms.Byte_Vector_size(*args, **kwargs)

    def clear(*args, **kwargs):
        """clear(self)"""
        return _algorithms.Byte_Vector_clear(*args, **kwargs)

    def swap(*args, **kwargs):
        """swap(self, v)"""
        return _algorithms.Byte_Vector_swap(*args, **kwargs)

    def get_allocator(*args, **kwargs):
        """get_allocator(self) -> std::vector<(char)>::allocator_type"""
        return _algorithms.Byte_Vector_get_allocator(*args, **kwargs)

    def begin(*args, **kwargs):
        """begin(self) -> std::vector<(char)>::const_iterator"""
        return _algorithms.Byte_Vector_begin(*args, **kwargs)

    def end(*args, **kwargs):
        """end(self) -> std::vector<(char)>::const_iterator"""
        return _algorithms.Byte_Vector_end(*args, **kwargs)

    def rbegin(*args, **kwargs):
        """rbegin(self) -> std::vector<(char)>::const_reverse_iterator"""
        return _algorithms.Byte_Vector_rbegin(*args, **kwargs)

    def rend(*args, **kwargs):
        """rend(self) -> std::vector<(char)>::const_reverse_iterator"""
        return _algorithms.Byte_Vector_rend(*args, **kwargs)

    def pop_back(*args, **kwargs):
        """pop_back(self)"""
        return _algorithms.Byte_Vector_pop_back(*args, **kwargs)

    def erase(*args):
        """
        erase(self, pos) -> std::vector<(char)>::iterator
        erase(self, first, last) -> std::vector<(char)>::iterator
        """
        return _algorithms.Byte_Vector_erase(*args)

    def __init__(self, *args): 
        """
        __init__(self) -> Byte_Vector
        __init__(self, ?) -> Byte_Vector
        __init__(self, size) -> Byte_Vector
        __init__(self, size, value) -> Byte_Vector
        """
        this = _algorithms.new_Byte_Vector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(*args, **kwargs):
        """push_back(self, x)"""
        return _algorithms.Byte_Vector_push_back(*args, **kwargs)

    def front(*args, **kwargs):
        """front(self) -> std::vector<(char)>::value_type"""
        return _algorithms.Byte_Vector_front(*args, **kwargs)

    def back(*args, **kwargs):
        """back(self) -> std::vector<(char)>::value_type"""
        return _algorithms.Byte_Vector_back(*args, **kwargs)

    def assign(*args, **kwargs):
        """assign(self, n, x)"""
        return _algorithms.Byte_Vector_assign(*args, **kwargs)

    def resize(*args):
        """
        resize(self, new_size)
        resize(self, new_size, x)
        """
        return _algorithms.Byte_Vector_resize(*args)

    def insert(*args):
        """
        insert(self, pos, x) -> std::vector<(char)>::iterator
        insert(self, pos, n, x)
        """
        return _algorithms.Byte_Vector_insert(*args)

    def reserve(*args, **kwargs):
        """reserve(self, n)"""
        return _algorithms.Byte_Vector_reserve(*args, **kwargs)

    def capacity(*args, **kwargs):
        """capacity(self) -> std::vector<(char)>::size_type"""
        return _algorithms.Byte_Vector_capacity(*args, **kwargs)

    __swig_destroy__ = _algorithms.delete_Byte_Vector
Byte_Vector_swigregister = _algorithms.Byte_Vector_swigregister
Byte_Vector_swigregister(Byte_Vector)

class ByteVector(Byte_Vector):
    """Proxy of C++ ByteVector class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args, **kwargs): 
        """__init__(self, n=0) -> ByteVector"""
        this = _algorithms.new_ByteVector(*args, **kwargs)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _algorithms.delete_ByteVector
ByteVector_swigregister = _algorithms.ByteVector_swigregister
ByteVector_swigregister(ByteVector)

class Size_T_Vector(object):
    """Proxy of C++ Size_T_Vector class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def iterator(*args, **kwargs):
        """iterator(self, PYTHON_SELF) -> PySwigIterator"""
        return _algorithms.Size_T_Vector_iterator(*args, **kwargs)

    def __iter__(self): return self.iterator()
    def __nonzero__(*args, **kwargs):
        """__nonzero__(self) -> bool"""
        return _algorithms.Size_T_Vector___nonzero__(*args, **kwargs)

    def __len__(*args, **kwargs):
        """__len__(self) -> size_type"""
        return _algorithms.Size_T_Vector___len__(*args, **kwargs)

    def pop(*args, **kwargs):
        """pop(self) -> value_type"""
        return _algorithms.Size_T_Vector_pop(*args, **kwargs)

    def __getslice__(*args, **kwargs):
        """__getslice__(self, i, j) -> Size_T_Vector"""
        return _algorithms.Size_T_Vector___getslice__(*args, **kwargs)

    def __setslice__(*args, **kwargs):
        """__setslice__(self, i, j, v)"""
        return _algorithms.Size_T_Vector___setslice__(*args, **kwargs)

    def __delslice__(*args, **kwargs):
        """__delslice__(self, i, j)"""
        return _algorithms.Size_T_Vector___delslice__(*args, **kwargs)

    def __delitem__(*args, **kwargs):
        """__delitem__(self, i)"""
        return _algorithms.Size_T_Vector___delitem__(*args, **kwargs)

    def __getitem__(*args, **kwargs):
        """__getitem__(self, i) -> value_type"""
        return _algorithms.Size_T_Vector___getitem__(*args, **kwargs)

    def __setitem__(*args, **kwargs):
        """__setitem__(self, i, x)"""
        return _algorithms.Size_T_Vector___setitem__(*args, **kwargs)

    def append(*args, **kwargs):
        """append(self, x)"""
        return _algorithms.Size_T_Vector_append(*args, **kwargs)

    def empty(*args, **kwargs):
        """empty(self) -> bool"""
        return _algorithms.Size_T_Vector_empty(*args, **kwargs)

    def size(*args, **kwargs):
        """size(self) -> size_type"""
        return _algorithms.Size_T_Vector_size(*args, **kwargs)

    def clear(*args, **kwargs):
        """clear(self)"""
        return _algorithms.Size_T_Vector_clear(*args, **kwargs)

    def swap(*args, **kwargs):
        """swap(self, v)"""
        return _algorithms.Size_T_Vector_swap(*args, **kwargs)

    def get_allocator(*args, **kwargs):
        """get_allocator(self) -> allocator_type"""
        return _algorithms.Size_T_Vector_get_allocator(*args, **kwargs)

    def begin(*args, **kwargs):
        """begin(self) -> const_iterator"""
        return _algorithms.Size_T_Vector_begin(*args, **kwargs)

    def end(*args, **kwargs):
        """end(self) -> const_iterator"""
        return _algorithms.Size_T_Vector_end(*args, **kwargs)

    def rbegin(*args, **kwargs):
        """rbegin(self) -> const_reverse_iterator"""
        return _algorithms.Size_T_Vector_rbegin(*args, **kwargs)

    def rend(*args, **kwargs):
        """rend(self) -> const_reverse_iterator"""
        return _algorithms.Size_T_Vector_rend(*args, **kwargs)

    def pop_back(*args, **kwargs):
        """pop_back(self)"""
        return _algorithms.Size_T_Vector_pop_back(*args, **kwargs)

    def erase(*args):
        """
        erase(self, pos) -> iterator
        erase(self, first, last) -> iterator
        """
        return _algorithms.Size_T_Vector_erase(*args)

    def __init__(self, *args): 
        """
        __init__(self) -> Size_T_Vector
        __init__(self, ?) -> Size_T_Vector
        __init__(self, size) -> Size_T_Vector
        __init__(self, size, value) -> Size_T_Vector
        """
        this = _algorithms.new_Size_T_Vector(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(*args, **kwargs):
        """push_back(self, x)"""
        return _algorithms.Size_T_Vector_push_back(*args, **kwargs)

    def front(*args, **kwargs):
        """front(self) -> value_type"""
        return _algorithms.Size_T_Vector_front(*args, **kwargs)

    def back(*args, **kwargs):
        """back(self) -> value_type"""
        return _algorithms.Size_T_Vector_back(*args, **kwargs)

    def assign(*args, **kwargs):
        """assign(self, n, x)"""
        return _algorithms.Size_T_Vector_assign(*args, **kwargs)

    def resize(*args):
        """
        resize(self, new_size)
        resize(self, new_size, x)
        """
        return _algorithms.Size_T_Vector_resize(*args)

    def insert(*args):
        """
        insert(self, pos, x) -> iterator
        insert(self, pos, n, x)
        """
        return _algorithms.Size_T_Vector_insert(*args)

    def reserve(*args, **kwargs):
        """reserve(self, n)"""
        return _algorithms.Size_T_Vector_reserve(*args, **kwargs)

    def capacity(*args, **kwargs):
        """capacity(self) -> size_type"""
        return _algorithms.Size_T_Vector_capacity(*args, **kwargs)

    __swig_destroy__ = _algorithms.delete_Size_T_Vector
Size_T_Vector_swigregister = _algorithms.Size_T_Vector_swigregister
Size_T_Vector_swigregister(Size_T_Vector)


def non_zeros_ui8(*args, **kwargs):
  """non_zeros_ui8(py_x, py_y) -> UInt32"""
  return _algorithms.non_zeros_ui8(*args, **kwargs)

def non_zeros_i32(*args, **kwargs):
  """non_zeros_i32(py_x, py_y) -> UInt32"""
  return _algorithms.non_zeros_i32(*args, **kwargs)

def non_zeros_f32(*args, **kwargs):
  """non_zeros_f32(py_x, py_y) -> UInt32"""
  return _algorithms.non_zeros_f32(*args, **kwargs)

def rightVecProdAtIndices(*args, **kwargs):
  """rightVecProdAtIndices(py_ind, py_x, py_y)"""
  return _algorithms.rightVecProdAtIndices(*args, **kwargs)
class FDRSpatial(object):
    """Proxy of C++ FDRSpatial class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    uniform = _algorithms.FDRSpatial_uniform
    gaussian = _algorithms.FDRSpatial_gaussian
    def __init__(self, *args): 
        """
        __init__(self, _nbabies, _nrows, _ncols, _nnzpr, _output_nnz, _stimulus_threshold, 
            _clone=False, coincidence_type=uniform, 
            _rf_x=0, _sigma=0.0, _seed=-1, _init_nz_val=1.0, 
            _threshold_cte=800.0, _normalization_sum=1000.0, 
            _normalization_freq=20, _hysteresis=1.0) -> FDRSpatial
        __init__(self) -> FDRSpatial
        """
        this = _algorithms.new_FDRSpatial(*args)
        try: self.this.append(this)
        except: self.this = this
    def version(*args, **kwargs):
        """version(self) -> string"""
        return _algorithms.FDRSpatial_version(*args, **kwargs)

    def nBabies(*args, **kwargs):
        """nBabies(self) -> size_type"""
        return _algorithms.FDRSpatial_nBabies(*args, **kwargs)

    def nRows(*args, **kwargs):
        """nRows(self) -> size_type"""
        return _algorithms.FDRSpatial_nRows(*args, **kwargs)

    def nCols(*args, **kwargs):
        """nCols(self) -> size_type"""
        return _algorithms.FDRSpatial_nCols(*args, **kwargs)

    def nNonZerosPerRow(*args, **kwargs):
        """nNonZerosPerRow(self) -> size_type"""
        return _algorithms.FDRSpatial_nNonZerosPerRow(*args, **kwargs)

    def nNonZeros(*args, **kwargs):
        """nNonZeros(self) -> size_type"""
        return _algorithms.FDRSpatial_nNonZeros(*args, **kwargs)

    def nNonZerosInOutput(*args, **kwargs):
        """nNonZerosInOutput(self) -> size_type"""
        return _algorithms.FDRSpatial_nNonZerosInOutput(*args, **kwargs)

    def getHysteresis(*args, **kwargs):
        """getHysteresis(self) -> value_type"""
        return _algorithms.FDRSpatial_getHysteresis(*args, **kwargs)

    def getStimulusThreshold(*args, **kwargs):
        """getStimulusThreshold(self) -> value_type"""
        return _algorithms.FDRSpatial_getStimulusThreshold(*args, **kwargs)

    def getHistogramThreshold(*args, **kwargs):
        """getHistogramThreshold(self) -> value_type"""
        return _algorithms.FDRSpatial_getHistogramThreshold(*args, **kwargs)

    def getNormalizationSum(*args, **kwargs):
        """getNormalizationSum(self) -> value_type"""
        return _algorithms.FDRSpatial_getNormalizationSum(*args, **kwargs)

    def getNormalizationFreq(*args, **kwargs):
        """getNormalizationFreq(self) -> value_type"""
        return _algorithms.FDRSpatial_getNormalizationFreq(*args, **kwargs)

    def reset(*args, **kwargs):
        """reset(self)"""
        return _algorithms.FDRSpatial_reset(*args, **kwargs)

    def setStoreDenseOutput(*args, **kwargs):
        """setStoreDenseOutput(self, x)"""
        return _algorithms.FDRSpatial_setStoreDenseOutput(*args, **kwargs)

    def getDenseOutput(*args, **kwargs):
        """getDenseOutput(self, babyIdx) -> std::vector<(nta::algorithms::FDRSpatial::value_type,std::allocator<(nta::algorithms::FDRSpatial::value_type)>)>"""
        return _algorithms.FDRSpatial_getDenseOutput(*args, **kwargs)

    def getPrevWinners(*args, **kwargs):
        """getPrevWinners(self) -> std::vector<(nta::algorithms::FDRSpatial::size_type,std::allocator<(nta::algorithms::FDRSpatial::size_type)>)>"""
        return _algorithms.FDRSpatial_getPrevWinners(*args, **kwargs)

    def get_ub(*args, **kwargs):
        """get_ub(self) -> std::vector<(nta::algorithms::FDRSpatial::size_type,std::allocator<(nta::algorithms::FDRSpatial::size_type)>)>"""
        return _algorithms.FDRSpatial_get_ub(*args, **kwargs)

    def set_cm(*args, **kwargs):
        """set_cm(self, cm_string)"""
        return _algorithms.FDRSpatial_set_cm(*args, **kwargs)

    def get_cm(*args, **kwargs):
        """get_cm(self) -> string"""
        return _algorithms.FDRSpatial_get_cm(*args, **kwargs)

    def get_truncated_cm(*args, **kwargs):
        """get_truncated_cm(self) -> string"""
        return _algorithms.FDRSpatial_get_truncated_cm(*args, **kwargs)

    def persistent_size(*args, **kwargs):
        """persistent_size(self) -> size_type"""
        return _algorithms.FDRSpatial_persistent_size(*args, **kwargs)

    def save(*args, **kwargs):
        """save(self, out_stream)"""
        return _algorithms.FDRSpatial_save(*args, **kwargs)

    def load(*args, **kwargs):
        """load(self, in_stream)"""
        return _algorithms.FDRSpatial_load(*args, **kwargs)

    def __init__(self, *args):
        self.this = _ALGORITHMS.new_FDRSpatial(*args)

    def __getstate__(self):
      """
      Used by the pickling mechanism to get state that will be saved.
      """
      return (self.toPyString(),)

    def __setstate__(self, tup):
      """
      Used by the pickling mechanism to restore state that was saved.
      """
      self.this = _ALGORITHMS.new_FDRSpatial()
      self.thisown = 1
      self.fromPyString(tup[0])

    def setCMFromDense(*args, **kwargs):
        """setCMFromDense(self, py_dense)"""
        return _algorithms.FDRSpatial_setCMFromDense(*args, **kwargs)

    def compute(*args, **kwargs):
        """compute(self, i, py_x, py_y, doLearn, doInfer)"""
        return _algorithms.FDRSpatial_compute(*args, **kwargs)

    def getDenseCoincidence(*args, **kwargs):
        """getDenseCoincidence(self, row) -> PyObject"""
        return _algorithms.FDRSpatial_getDenseCoincidence(*args, **kwargs)

    def getSparseCoincidence(*args, **kwargs):
        """getSparseCoincidence(self, row) -> PyObject"""
        return _algorithms.FDRSpatial_getSparseCoincidence(*args, **kwargs)

    def overlaps(*args, **kwargs):
        """overlaps(self, py_x, py_output) -> PyObject"""
        return _algorithms.FDRSpatial_overlaps(*args, **kwargs)

    def toPyString(*args, **kwargs):
        """toPyString(self) -> PyObject"""
        return _algorithms.FDRSpatial_toPyString(*args, **kwargs)

    def fromPyString(*args, **kwargs):
        """fromPyString(self, s) -> bool"""
        return _algorithms.FDRSpatial_fromPyString(*args, **kwargs)

    __swig_destroy__ = _algorithms.delete_FDRSpatial
FDRSpatial_swigregister = _algorithms.FDRSpatial_swigregister
FDRSpatial_swigregister(FDRSpatial)


def CSPSweep(*args, **kwargs):
  """
    CSPSweep(cfx, cfy, stimulusThreshold, inhibitionRadius, py_denseOutput, 
        py_afterInhibition) -> PyObject
    """
  return _algorithms.CSPSweep(*args, **kwargs)
P_INC = _algorithms.P_INC
class Inhibition(object):
    """Proxy of C++ Inhibition class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args, **kwargs): 
        """__init__(self, _c_height=0, _c_width=0, _desired_density=1.0, _small=0) -> Inhibition"""
        this = _algorithms.new_Inhibition(*args, **kwargs)
        try: self.this.append(this)
        except: self.this = this
    def initialize(*args, **kwargs):
        """initialize(self, _c_height=0, _c_width=0, _desired_density=1.0, _small=0)"""
        return _algorithms.Inhibition_initialize(*args, **kwargs)

    def getSmall(*args, **kwargs):
        """getSmall(self) -> int"""
        return _algorithms.Inhibition_getSmall(*args, **kwargs)

    def getInhibitionRadius(*args, **kwargs):
        """getInhibitionRadius(self) -> size_type"""
        return _algorithms.Inhibition_getInhibitionRadius(*args, **kwargs)

    def getHeight(*args, **kwargs):
        """getHeight(self) -> size_type"""
        return _algorithms.Inhibition_getHeight(*args, **kwargs)

    def getWidth(*args, **kwargs):
        """getWidth(self) -> size_type"""
        return _algorithms.Inhibition_getWidth(*args, **kwargs)

    def n_bytes(*args, **kwargs):
        """n_bytes(self) -> size_type"""
        return _algorithms.Inhibition_n_bytes(*args, **kwargs)

    def estimate_max_size_bytes(*args, **kwargs):
        """estimate_max_size_bytes(self) -> size_type"""
        return _algorithms.Inhibition_estimate_max_size_bytes(*args, **kwargs)

    def setDesiredOutputDensity(*args, **kwargs):
        """setDesiredOutputDensity(self, v)"""
        return _algorithms.Inhibition_setDesiredOutputDensity(*args, **kwargs)

    def __init__(self, *args):
      this = _ALGORITHMS.new_Inhibition(*args)
      try:
        self.this.append(this)
      except:
        self.this = this

    def compute(*args, **kwargs):
        """compute(self, py_x, py_y, stimulus_threshold, k=.95) -> UInt32"""
        return _algorithms.Inhibition_compute(*args, **kwargs)

    __swig_destroy__ = _algorithms.delete_Inhibition
Inhibition_swigregister = _algorithms.Inhibition_swigregister
Inhibition_swigregister(Inhibition)

class Inhibition2(object):
    """Proxy of C++ Inhibition2 class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args, **kwargs): 
        """__init__(self, _c_height=0, _c_width=0, _inhibition_radius=10, _local_area_density=0.02) -> Inhibition2"""
        this = _algorithms.new_Inhibition2(*args, **kwargs)
        try: self.this.append(this)
        except: self.this = this
    def initialize(*args, **kwargs):
        """initialize(self, _c_height=0, _c_width=0, _inhibition_radius=10, _local_area_density=0.02)"""
        return _algorithms.Inhibition2_initialize(*args, **kwargs)

    def getInhibitionRadius(*args, **kwargs):
        """getInhibitionRadius(self) -> size_type"""
        return _algorithms.Inhibition2_getInhibitionRadius(*args, **kwargs)

    def getLocalAreaDensity(*args, **kwargs):
        """getLocalAreaDensity(self) -> value_type"""
        return _algorithms.Inhibition2_getLocalAreaDensity(*args, **kwargs)

    def getHeight(*args, **kwargs):
        """getHeight(self) -> size_type"""
        return _algorithms.Inhibition2_getHeight(*args, **kwargs)

    def getWidth(*args, **kwargs):
        """getWidth(self) -> size_type"""
        return _algorithms.Inhibition2_getWidth(*args, **kwargs)

    def setDesiredOutputDensity(*args, **kwargs):
        """setDesiredOutputDensity(self, v)"""
        return _algorithms.Inhibition2_setDesiredOutputDensity(*args, **kwargs)

    def __init__(self, *args):
      this = _ALGORITHMS.new_Inhibition2(*args)
      try:
        self.this.append(this)
      except:
        self.this = this

    def compute(*args, **kwargs):
        """compute(self, py_x, py_y, stimulus_threshold, add_to_winners) -> UInt32"""
        return _algorithms.Inhibition2_compute(*args, **kwargs)

    __swig_destroy__ = _algorithms.delete_Inhibition2
Inhibition2_swigregister = _algorithms.Inhibition2_swigregister
Inhibition2_swigregister(Inhibition2)

class FDRCSpatial(object):
    """Proxy of C++ FDRCSpatial class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, _input_height, _input_width, _c_height, _c_width, _c_rf_radius, 
            _c_pool_size, _c_nnz, _desired_density_learning=.1, 
            _desired_density_inference=.1, 
            _stimulus_threshold_learning=0, _stimulus_threshold_inference=1, 
            _convolution_k_learning=.95, 
            _convolution_k_inference=.95, _seed=-1, 
            _threshold_cte=800.0, _normalization_sum=1000.0, 
            _clone_height=0, _clone_width=0, small_threshold_bytes=600*1024*1024) -> FDRCSpatial
        __init__(self) -> FDRCSpatial
        """
        this = _algorithms.new_FDRCSpatial(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _algorithms.delete_FDRCSpatial
    def version(*args, **kwargs):
        """version(self) -> string"""
        return _algorithms.FDRCSpatial_version(*args, **kwargs)

    def isCloned(*args, **kwargs):
        """isCloned(self) -> bool"""
        return _algorithms.FDRCSpatial_isCloned(*args, **kwargs)

    def getNMasters(*args, **kwargs):
        """getNMasters(self) -> size_type"""
        return _algorithms.FDRCSpatial_getNMasters(*args, **kwargs)

    def getNColumns(*args, **kwargs):
        """getNColumns(self) -> size_type"""
        return _algorithms.FDRCSpatial_getNColumns(*args, **kwargs)

    def getInputSize(*args, **kwargs):
        """getInputSize(self) -> size_type"""
        return _algorithms.FDRCSpatial_getInputSize(*args, **kwargs)

    def getRFSide(*args, **kwargs):
        """getRFSide(self) -> size_type"""
        return _algorithms.FDRCSpatial_getRFSide(*args, **kwargs)

    def getBitPoolSizePerCoincidence(*args, **kwargs):
        """getBitPoolSizePerCoincidence(self) -> size_type"""
        return _algorithms.FDRCSpatial_getBitPoolSizePerCoincidence(*args, **kwargs)

    def getNSamplingBitsPerCoincidence(*args, **kwargs):
        """getNSamplingBitsPerCoincidence(self) -> size_type"""
        return _algorithms.FDRCSpatial_getNSamplingBitsPerCoincidence(*args, **kwargs)

    def getInhibitionRadius(*args, **kwargs):
        """getInhibitionRadius(self) -> size_type"""
        return _algorithms.FDRCSpatial_getInhibitionRadius(*args, **kwargs)

    def getStimulusThresholdForLearning(*args, **kwargs):
        """getStimulusThresholdForLearning(self) -> size_type"""
        return _algorithms.FDRCSpatial_getStimulusThresholdForLearning(*args, **kwargs)

    def getStimulusThresholdForInference(*args, **kwargs):
        """getStimulusThresholdForInference(self) -> size_type"""
        return _algorithms.FDRCSpatial_getStimulusThresholdForInference(*args, **kwargs)

    def getHistogramThreshold(*args, **kwargs):
        """getHistogramThreshold(self) -> value_type"""
        return _algorithms.FDRCSpatial_getHistogramThreshold(*args, **kwargs)

    def getNormalizationSum(*args, **kwargs):
        """getNormalizationSum(self) -> value_type"""
        return _algorithms.FDRCSpatial_getNormalizationSum(*args, **kwargs)

    def getInputShape(*args, **kwargs):
        """getInputShape(self) -> std::pair<(nta::algorithms::FDRCSpatial::size_type,nta::algorithms::FDRCSpatial::size_type)>"""
        return _algorithms.FDRCSpatial_getInputShape(*args, **kwargs)

    def getCoincidenceFieldShape(*args, **kwargs):
        """getCoincidenceFieldShape(self) -> std::pair<(nta::algorithms::FDRCSpatial::size_type,nta::algorithms::FDRCSpatial::size_type)>"""
        return _algorithms.FDRCSpatial_getCoincidenceFieldShape(*args, **kwargs)

    def getCloningShape(*args, **kwargs):
        """getCloningShape(self) -> std::pair<(nta::algorithms::FDRCSpatial::size_type,nta::algorithms::FDRCSpatial::size_type)>"""
        return _algorithms.FDRCSpatial_getCloningShape(*args, **kwargs)

    def n_bytes(*args, **kwargs):
        """n_bytes(self) -> size_t"""
        return _algorithms.FDRCSpatial_n_bytes(*args, **kwargs)

    def is_small(*args, **kwargs):
        """is_small(self) -> bool"""
        return _algorithms.FDRCSpatial_is_small(*args, **kwargs)

    def print_size_stats(*args, **kwargs):
        """print_size_stats(self, estimate=False)"""
        return _algorithms.FDRCSpatial_print_size_stats(*args, **kwargs)

    def estimate_max_size_bytes(*args, **kwargs):
        """estimate_max_size_bytes(self) -> size_type"""
        return _algorithms.FDRCSpatial_estimate_max_size_bytes(*args, **kwargs)

    def reset(*args, **kwargs):
        """reset(self)"""
        return _algorithms.FDRCSpatial_reset(*args, **kwargs)

    def setStoreDenseOutput(*args, **kwargs):
        """setStoreDenseOutput(self, x)"""
        return _algorithms.FDRCSpatial_setStoreDenseOutput(*args, **kwargs)

    def cm(*args, **kwargs):
        """cm(self, withCounts=True, learnt=False) -> _SparseMatrix32"""
        return _algorithms.FDRCSpatial_cm(*args, **kwargs)

    def cm_t(*args, **kwargs):
        """cm_t(self) -> _SparseMatrix32"""
        return _algorithms.FDRCSpatial_cm_t(*args, **kwargs)

    def persistent_size(*args, **kwargs):
        """persistent_size(self) -> size_type"""
        return _algorithms.FDRCSpatial_persistent_size(*args, **kwargs)

    def save(*args, **kwargs):
        """save(self, out_stream)"""
        return _algorithms.FDRCSpatial_save(*args, **kwargs)

    def load(*args, **kwargs):
        """load(self, in_stream)"""
        return _algorithms.FDRCSpatial_load(*args, **kwargs)

    def __init__(self, *args):
        self.this = _ALGORITHMS.new_FDRCSpatial(*args)

    def __getstate__(self):
      """
      Used by the pickling mechanism to get state that will be saved.
      """
      return (self.toPyString(),)

    def __setstate__(self, tup):
      """
      Used by the pickling mechanism to restore state that was saved.
      """
      self.this = _ALGORITHMS.new_FDRCSpatial()
      self.thisown = 1
      self.fromPyString(tup[0])

    def compute(*args, **kwargs):
        """compute(self, py_x, py_y, doLearn, doInfer)"""
        return _algorithms.FDRCSpatial_compute(*args, **kwargs)

    def getSparseCoincidence(*args, **kwargs):
        """getSparseCoincidence(self, row, learnt=False) -> PyObject"""
        return _algorithms.FDRCSpatial_getSparseCoincidence(*args, **kwargs)

    def getHistogram(*args, **kwargs):
        """getHistogram(self, c) -> PyObject"""
        return _algorithms.FDRCSpatial_getHistogram(*args, **kwargs)

    def getMasterLearnedCoincidence(*args, **kwargs):
        """getMasterLearnedCoincidence(self, m) -> PyObject"""
        return _algorithms.FDRCSpatial_getMasterLearnedCoincidence(*args, **kwargs)

    def getMasterHistogram(*args, **kwargs):
        """getMasterHistogram(self, m) -> PyObject"""
        return _algorithms.FDRCSpatial_getMasterHistogram(*args, **kwargs)

    def getDenseOutput(*args, **kwargs):
        """getDenseOutput(self) -> PyObject"""
        return _algorithms.FDRCSpatial_getDenseOutput(*args, **kwargs)

    def toPyString(*args, **kwargs):
        """toPyString(self) -> PyObject"""
        return _algorithms.FDRCSpatial_toPyString(*args, **kwargs)

    def fromPyString(*args, **kwargs):
        """fromPyString(self, s) -> bool"""
        return _algorithms.FDRCSpatial_fromPyString(*args, **kwargs)

FDRCSpatial_swigregister = _algorithms.FDRCSpatial_swigregister
FDRCSpatial_swigregister(FDRCSpatial)


def generate2DGaussianSample(*args, **kwargs):
  """generate2DGaussianSample(nrows, ncols, nnzpr, rf_x, sigma, seed=-1, sorted=True) -> PyObject"""
  return _algorithms.generate2DGaussianSample(*args, **kwargs)

def cpp_overlap(*args, **kwargs):
  """
    cpp_overlap(py_cloneMapFlat, py_inputSlices, py_coincSlices, py_inputShaped, 
        py_masterConnectedM, stimulusThreshold, 
        py_overlaps)
    """
  return _algorithms.cpp_overlap(*args, **kwargs)

def cpp_overlap_sbm(*args, **kwargs):
  """
    cpp_overlap_sbm(py_cloneMapFlat, py_inputSlices, py_coincSlices, py_inputShaped, 
        py_masterConnectedM, stimulusThreshold, 
        py_overlaps)
    """
  return _algorithms.cpp_overlap_sbm(*args, **kwargs)

def cpp_updateDutyCycles(*args, **kwargs):
  """cpp_updateDutyCycles(dutyCyclePeriod, py_cloneMapFlat, py_onCells, py_dutyCycles)"""
  return _algorithms.cpp_updateDutyCycles(*args, **kwargs)

def adjustMasterValidPermanence(*args, **kwargs):
  """
    adjustMasterValidPermanence(columnNum, masterNum, inputNCols, masterNCols, synPermActiveInc, 
        synPermInactiveDec, synPermActiveSharedDec, 
        py_inputShaped, py_inputUse, py_inputSlices, 
        py_coincSlices, py_synPermBoostFactors, 
        py_masterPermanence)
    """
  return _algorithms.adjustMasterValidPermanence(*args, **kwargs)

def getSegmentActivityLevel(*args, **kwargs):
  """getSegmentActivityLevel(py_seg, py_state, connectedSynapsesOnly, connectedPerm) -> UInt32"""
  return _algorithms.getSegmentActivityLevel(*args, **kwargs)

def getSegmentAvgPermanence(*args, **kwargs):
  """getSegmentAvgPermanence(py_seg, connectedPerm) -> Real32"""
  return _algorithms.getSegmentAvgPermanence(*args, **kwargs)

def getSegmentSumActivePermanence(*args, **kwargs):
  """getSegmentSumActivePermanence(py_seg, py_state, connectedPerm) -> Real32"""
  return _algorithms.getSegmentSumActivePermanence(*args, **kwargs)

def isSegmentActive(*args, **kwargs):
  """isSegmentActive(py_seg, py_state, connectedPerm, activationThreshold) -> bool"""
  return _algorithms.isSegmentActive(*args, **kwargs)
class CState(object):
    """Proxy of C++ CState class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    VERSION = _algorithms.CState_VERSION
    def __init__(self, *args, **kwargs): 
        """__init__(self) -> CState"""
        this = _algorithms.new_CState(*args, **kwargs)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _algorithms.delete_CState
    def initialize(*args, **kwargs):
        """initialize(self, nCells) -> bool"""
        return _algorithms.CState_initialize(*args, **kwargs)

    def usePythonMemory(*args, **kwargs):
        """usePythonMemory(self, pData, nCells)"""
        return _algorithms.CState_usePythonMemory(*args, **kwargs)

    def isSet(*args, **kwargs):
        """isSet(self, cellIdx) -> bool"""
        return _algorithms.CState_isSet(*args, **kwargs)

    def set(*args, **kwargs):
        """set(self, cellIdx)"""
        return _algorithms.CState_set(*args, **kwargs)

    def resetAll(*args, **kwargs):
        """resetAll(self)"""
        return _algorithms.CState_resetAll(*args, **kwargs)

    def arrayPtr(*args, **kwargs):
        """arrayPtr(self) -> Byte"""
        return _algorithms.CState_arrayPtr(*args, **kwargs)

    def load(*args, **kwargs):
        """load(self, inStream)"""
        return _algorithms.CState_load(*args, **kwargs)

    def version(*args, **kwargs):
        """version(self) -> UInt"""
        return _algorithms.CState_version(*args, **kwargs)

CState_swigregister = _algorithms.CState_swigregister
CState_swigregister(CState)

class CStateIndexed(CState):
    """Proxy of C++ CStateIndexed class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    VERSION = _algorithms.CStateIndexed_VERSION
    def __init__(self, *args, **kwargs): 
        """__init__(self) -> CStateIndexed"""
        this = _algorithms.new_CStateIndexed(*args, **kwargs)
        try: self.this.append(this)
        except: self.this = this
    def cellsOn(*args, **kwargs):
        """cellsOn(self, fSorted=False) -> std::vector<(nta::UInt,std::allocator<(nta::UInt)>)>"""
        return _algorithms.CStateIndexed_cellsOn(*args, **kwargs)

    def set(*args, **kwargs):
        """set(self, cellIdx)"""
        return _algorithms.CStateIndexed_set(*args, **kwargs)

    def resetAll(*args, **kwargs):
        """resetAll(self)"""
        return _algorithms.CStateIndexed_resetAll(*args, **kwargs)

    def load(*args, **kwargs):
        """load(self, inStream)"""
        return _algorithms.CStateIndexed_load(*args, **kwargs)

    def version(*args, **kwargs):
        """version(self) -> UInt"""
        return _algorithms.CStateIndexed_version(*args, **kwargs)

    __swig_destroy__ = _algorithms.delete_CStateIndexed
CStateIndexed_swigregister = _algorithms.CStateIndexed_swigregister
CStateIndexed_swigregister(CStateIndexed)

class InSynapseOrder(object):
    """Proxy of C++ InSynapseOrder class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __call__(*args, **kwargs):
        """__call__(self, a, b) -> bool"""
        return _algorithms.InSynapseOrder___call__(*args, **kwargs)

    def __init__(self, *args, **kwargs): 
        """__init__(self) -> InSynapseOrder"""
        this = _algorithms.new_InSynapseOrder(*args, **kwargs)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _algorithms.delete_InSynapseOrder
InSynapseOrder_swigregister = _algorithms.InSynapseOrder_swigregister
InSynapseOrder_swigregister(InSynapseOrder)
cvar = _algorithms.cvar
_numTiers = cvar._numTiers
_dutyCycleTiers = cvar._dutyCycleTiers
_dutyCycleAlphas = cvar._dutyCycleAlphas

class Segment(object):
    """Proxy of C++ Segment class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    _totalActivations = _swig_property(_algorithms.Segment__totalActivations_get, _algorithms.Segment__totalActivations_set)
    _positiveActivations = _swig_property(_algorithms.Segment__positiveActivations_get, _algorithms.Segment__positiveActivations_set)
    _lastActiveIteration = _swig_property(_algorithms.Segment__lastActiveIteration_get, _algorithms.Segment__lastActiveIteration_set)
    _lastPosDutyCycle = _swig_property(_algorithms.Segment__lastPosDutyCycle_get, _algorithms.Segment__lastPosDutyCycle_set)
    _lastPosDutyCycleIteration = _swig_property(_algorithms.Segment__lastPosDutyCycleIteration_get, _algorithms.Segment__lastPosDutyCycleIteration_set)
    def __init__(self, *args): 
        """
        __init__(self) -> Segment
        __init__(self, _s, frequency, seqSegFlag, permConnected, iteration) -> Segment
        __init__(self, o) -> Segment
        """
        this = _algorithms.new_Segment(*args)
        try: self.this.append(this)
        except: self.this = this
    def invariants(*args, **kwargs):
        """invariants(self) -> bool"""
        return _algorithms.Segment_invariants(*args, **kwargs)

    def checkConnected(*args, **kwargs):
        """checkConnected(self, permConnected) -> bool"""
        return _algorithms.Segment_checkConnected(*args, **kwargs)

    def empty(*args, **kwargs):
        """empty(self) -> bool"""
        return _algorithms.Segment_empty(*args, **kwargs)

    def size(*args, **kwargs):
        """size(self) -> UInt"""
        return _algorithms.Segment_size(*args, **kwargs)

    def isSequenceSegment(*args, **kwargs):
        """isSequenceSegment(self) -> bool"""
        return _algorithms.Segment_isSequenceSegment(*args, **kwargs)

    def frequency(*args, **kwargs):
        """frequency(self) -> Real"""
        return _algorithms.Segment_frequency(*args, **kwargs)

    def getFrequency(*args, **kwargs):
        """getFrequency(self) -> Real"""
        return _algorithms.Segment_getFrequency(*args, **kwargs)

    def nConnected(*args, **kwargs):
        """nConnected(self) -> UInt"""
        return _algorithms.Segment_nConnected(*args, **kwargs)

    def getTotalActivations(*args, **kwargs):
        """getTotalActivations(self) -> UInt"""
        return _algorithms.Segment_getTotalActivations(*args, **kwargs)

    def getPositiveActivations(*args, **kwargs):
        """getPositiveActivations(self) -> UInt"""
        return _algorithms.Segment_getPositiveActivations(*args, **kwargs)

    def getLastActiveIteration(*args, **kwargs):
        """getLastActiveIteration(self) -> UInt"""
        return _algorithms.Segment_getLastActiveIteration(*args, **kwargs)

    def getLastPosDutyCycle(*args, **kwargs):
        """getLastPosDutyCycle(self) -> Real"""
        return _algorithms.Segment_getLastPosDutyCycle(*args, **kwargs)

    def getLastPosDutyCycleIteration(*args, **kwargs):
        """getLastPosDutyCycleIteration(self) -> UInt"""
        return _algorithms.Segment_getLastPosDutyCycleIteration(*args, **kwargs)

    def has(*args, **kwargs):
        """has(self, srcCellIdx) -> bool"""
        return _algorithms.Segment_has(*args, **kwargs)

    def setPermanence(*args, **kwargs):
        """setPermanence(self, idx, val)"""
        return _algorithms.Segment_setPermanence(*args, **kwargs)

    def getPermanence(*args, **kwargs):
        """getPermanence(self, idx) -> Real"""
        return _algorithms.Segment_getPermanence(*args, **kwargs)

    def getSrcCellIdx(*args, **kwargs):
        """getSrcCellIdx(self, idx) -> UInt"""
        return _algorithms.Segment_getSrcCellIdx(*args, **kwargs)

    def getSrcCellIndices(*args, **kwargs):
        """getSrcCellIndices(self, srcCells)"""
        return _algorithms.Segment_getSrcCellIndices(*args, **kwargs)

    def clear(*args, **kwargs):
        """clear(self)"""
        return _algorithms.Segment_clear(*args, **kwargs)

    def addSynapses(*args, **kwargs):
        """addSynapses(self, srcCells, initStrength, permConnected)"""
        return _algorithms.Segment_addSynapses(*args, **kwargs)

    def recomputeConnected(*args, **kwargs):
        """recomputeConnected(self, permConnected)"""
        return _algorithms.Segment_recomputeConnected(*args, **kwargs)

    def decaySynapses2(*args, **kwargs):
        """decaySynapses2(self, decay, removed, permConnected)"""
        return _algorithms.Segment_decaySynapses2(*args, **kwargs)

    def decaySynapses(*args, **kwargs):
        """decaySynapses(self, decay, removed, permConnected, doDecay=True)"""
        return _algorithms.Segment_decaySynapses(*args, **kwargs)

    def freeNSynapses(*args, **kwargs):
        """
        freeNSynapses(self, numToFree, inactiveSynapseIndices, inactiveSegmentIndices, 
            activeSynapseIndices, activeSegmentIndices, 
            removed, verbosity, nCellsPerCol, permMax)
        """
        return _algorithms.Segment_freeNSynapses(*args, **kwargs)

    def isActive(*args, **kwargs):
        """isActive(self, activities, permConnected, activationThreshold) -> bool"""
        return _algorithms.Segment_isActive(*args, **kwargs)

    def computeActivity(*args, **kwargs):
        """computeActivity(self, activities, permConnected, connectedSynapsesOnly) -> UInt"""
        return _algorithms.Segment_computeActivity(*args, **kwargs)

    def dutyCycle(*args, **kwargs):
        """dutyCycle(self, iteration, active, readOnly) -> Real"""
        return _algorithms.Segment_dutyCycle(*args, **kwargs)

    def atDutyCycleTier(*args, **kwargs):
        """atDutyCycleTier(iteration) -> bool"""
        return _algorithms.Segment_atDutyCycleTier(*args, **kwargs)

    atDutyCycleTier = staticmethod(atDutyCycleTier)
    def persistentSize(*args, **kwargs):
        """persistentSize(self) -> UInt"""
        return _algorithms.Segment_persistentSize(*args, **kwargs)

    def save(*args, **kwargs):
        """save(self, outStream)"""
        return _algorithms.Segment_save(*args, **kwargs)

    def load(*args, **kwargs):
        """load(self, inStream)"""
        return _algorithms.Segment_load(*args, **kwargs)

    __swig_destroy__ = _algorithms.delete_Segment
Segment_swigregister = _algorithms.Segment_swigregister
Segment_swigregister(Segment)

def Segment_atDutyCycleTier(*args, **kwargs):
  """Segment_atDutyCycleTier(iteration) -> bool"""
  return _algorithms.Segment_atDutyCycleTier(*args, **kwargs)

class SegmentUpdate(object):
    """Proxy of C++ SegmentUpdate class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> SegmentUpdate
        __init__(self, cellIdx, segIdx, sequenceSegment, timeStamp, synapses=std::vector< nta::UInt >(), 
            phase1Flag=False, 
            weaklyPredicting=False, cells=None) -> SegmentUpdate
        __init__(self, o) -> SegmentUpdate
        """
        this = _algorithms.new_SegmentUpdate(*args)
        try: self.this.append(this)
        except: self.this = this
    def isSequenceSegment(*args, **kwargs):
        """isSequenceSegment(self) -> bool"""
        return _algorithms.SegmentUpdate_isSequenceSegment(*args, **kwargs)

    def cellIdx(*args, **kwargs):
        """cellIdx(self) -> UInt"""
        return _algorithms.SegmentUpdate_cellIdx(*args, **kwargs)

    def segIdx(*args, **kwargs):
        """segIdx(self) -> UInt"""
        return _algorithms.SegmentUpdate_segIdx(*args, **kwargs)

    def timeStamp(*args, **kwargs):
        """timeStamp(self) -> UInt"""
        return _algorithms.SegmentUpdate_timeStamp(*args, **kwargs)

    def begin(*args, **kwargs):
        """begin(self) -> const_iterator"""
        return _algorithms.SegmentUpdate_begin(*args, **kwargs)

    def end(*args, **kwargs):
        """end(self) -> const_iterator"""
        return _algorithms.SegmentUpdate_end(*args, **kwargs)

    def size(*args, **kwargs):
        """size(self) -> UInt"""
        return _algorithms.SegmentUpdate_size(*args, **kwargs)

    def empty(*args, **kwargs):
        """empty(self) -> bool"""
        return _algorithms.SegmentUpdate_empty(*args, **kwargs)

    def isNewSegment(*args, **kwargs):
        """isNewSegment(self) -> bool"""
        return _algorithms.SegmentUpdate_isNewSegment(*args, **kwargs)

    def isPhase1Segment(*args, **kwargs):
        """isPhase1Segment(self) -> bool"""
        return _algorithms.SegmentUpdate_isPhase1Segment(*args, **kwargs)

    def isWeaklyPredicting(*args, **kwargs):
        """isWeaklyPredicting(self) -> bool"""
        return _algorithms.SegmentUpdate_isWeaklyPredicting(*args, **kwargs)

    def invariants(*args, **kwargs):
        """invariants(self, cells=None) -> bool"""
        return _algorithms.SegmentUpdate_invariants(*args, **kwargs)

    def save(*args, **kwargs):
        """save(self, outStream)"""
        return _algorithms.SegmentUpdate_save(*args, **kwargs)

    def load(*args, **kwargs):
        """load(self, inStream)"""
        return _algorithms.SegmentUpdate_load(*args, **kwargs)

    __swig_destroy__ = _algorithms.delete_SegmentUpdate
SegmentUpdate_swigregister = _algorithms.SegmentUpdate_swigregister
SegmentUpdate_swigregister(SegmentUpdate)

class OutSynapse(object):
    """Proxy of C++ OutSynapse class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self, dstCellIdx=(UInt) -1, dstSegIdx=(UInt) -1) -> OutSynapse
        __init__(self, o) -> OutSynapse
        """
        this = _algorithms.new_OutSynapse(*args)
        try: self.this.append(this)
        except: self.this = this
    def dstCellIdx(*args, **kwargs):
        """dstCellIdx(self) -> UInt"""
        return _algorithms.OutSynapse_dstCellIdx(*args, **kwargs)

    def dstSegIdx(*args, **kwargs):
        """dstSegIdx(self) -> UInt"""
        return _algorithms.OutSynapse_dstSegIdx(*args, **kwargs)

    def goesTo(*args, **kwargs):
        """goesTo(self, dstCellIdx, dstSegIdx) -> bool"""
        return _algorithms.OutSynapse_goesTo(*args, **kwargs)

    def equals(*args, **kwargs):
        """equals(self, o) -> bool"""
        return _algorithms.OutSynapse_equals(*args, **kwargs)

    def invariants(*args, **kwargs):
        """invariants(self, cells=None) -> bool"""
        return _algorithms.OutSynapse_invariants(*args, **kwargs)

    __swig_destroy__ = _algorithms.delete_OutSynapse
OutSynapse_swigregister = _algorithms.OutSynapse_swigregister
OutSynapse_swigregister(OutSynapse)


def __eq__(*args, **kwargs):
  """__eq__(a, b) -> bool"""
  return _algorithms.__eq__(*args, **kwargs)
class InSynapse(object):
    """Proxy of C++ InSynapse class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> InSynapse
        __init__(self, srcCellIdx, permanence) -> InSynapse
        __init__(self, o) -> InSynapse
        """
        this = _algorithms.new_InSynapse(*args)
        try: self.this.append(this)
        except: self.this = this
    def srcCellIdx(*args, **kwargs):
        """srcCellIdx(self) -> UInt"""
        return _algorithms.InSynapse_srcCellIdx(*args, **kwargs)

    def permanence(*args):
        """
        permanence(self) -> Real
        permanence(self) -> Real
        """
        return _algorithms.InSynapse_permanence(*args)

    __swig_destroy__ = _algorithms.delete_InSynapse
InSynapse_swigregister = _algorithms.InSynapse_swigregister
InSynapse_swigregister(InSynapse)

class Cell(object):
    """Proxy of C++ Cell class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args, **kwargs): 
        """__init__(self) -> Cell"""
        this = _algorithms.new_Cell(*args, **kwargs)
        try: self.this.append(this)
        except: self.this = this
    def empty(*args, **kwargs):
        """empty(self) -> bool"""
        return _algorithms.Cell_empty(*args, **kwargs)

    def nSynapses(*args, **kwargs):
        """nSynapses(self) -> UInt"""
        return _algorithms.Cell_nSynapses(*args, **kwargs)

    def size(*args, **kwargs):
        """size(self) -> UInt"""
        return _algorithms.Cell_size(*args, **kwargs)

    def nSegments(*args, **kwargs):
        """nSegments(self) -> UInt"""
        return _algorithms.Cell_nSegments(*args, **kwargs)

    def getNonEmptySegList(*args, **kwargs):
        """getNonEmptySegList(self) -> std::vector<(nta::UInt,std::allocator<(nta::UInt)>)>"""
        return _algorithms.Cell_getNonEmptySegList(*args, **kwargs)

    def getSegment(*args, **kwargs):
        """getSegment(self, segIdx) -> Segment"""
        return _algorithms.Cell_getSegment(*args, **kwargs)

    def getFreeSegment(*args, **kwargs):
        """
        getFreeSegment(self, synapses, initFrequency, sequenceSegmentFlag, permConnected, 
            iteration) -> UInt
        """
        return _algorithms.Cell_getFreeSegment(*args, **kwargs)

    def setSegmentOrder(*args, **kwargs):
        """setSegmentOrder(matchPythonOrder)"""
        return _algorithms.Cell_setSegmentOrder(*args, **kwargs)

    setSegmentOrder = staticmethod(setSegmentOrder)
    def updateDutyCycle(*args, **kwargs):
        """updateDutyCycle(self, iterations)"""
        return _algorithms.Cell_updateDutyCycle(*args, **kwargs)

    def rebalanceSegments(*args, **kwargs):
        """rebalanceSegments(self)"""
        return _algorithms.Cell_rebalanceSegments(*args, **kwargs)

    def getMostActiveSegment(*args, **kwargs):
        """getMostActiveSegment(self) -> UInt"""
        return _algorithms.Cell_getMostActiveSegment(*args, **kwargs)

    def releaseSegment(*args, **kwargs):
        """releaseSegment(self, segIdx)"""
        return _algorithms.Cell_releaseSegment(*args, **kwargs)

    def invariants(*args, **kwargs):
        """invariants(self, ?=None) -> bool"""
        return _algorithms.Cell_invariants(*args, **kwargs)

    def persistentSize(*args, **kwargs):
        """persistentSize(self) -> UInt"""
        return _algorithms.Cell_persistentSize(*args, **kwargs)

    def save(*args, **kwargs):
        """save(self, outStream)"""
        return _algorithms.Cell_save(*args, **kwargs)

    def load(*args, **kwargs):
        """load(self, inStream)"""
        return _algorithms.Cell_load(*args, **kwargs)

    __swig_destroy__ = _algorithms.delete_Cell
Cell_swigregister = _algorithms.Cell_swigregister
Cell_swigregister(Cell)

def Cell_setSegmentOrder(*args, **kwargs):
  """Cell_setSegmentOrder(matchPythonOrder)"""
  return _algorithms.Cell_setSegmentOrder(*args, **kwargs)

def Segment3(*args, **keywords):
   return Segment3_32(*args)

class Cells4(object):
    """Proxy of C++ Cells4 class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    VERSION = _algorithms.Cells4_VERSION
    def __init__(self, *args, **kwargs): 
        """
        __init__(self, nColumns=0, nCellsPerCol=0, activationThreshold=1, 
            minThreshold=1, newSynapseCount=1, segUpdateValidDuration=1, 
            permInitial=.5, permConnected=.8, 
            permMax=1, permDec=.1, permInc=.1, globalDecay=0, 
            doPooling=False, seed=-1, doItAll=False, 
            checkSynapseConsistency=False) -> Cells4
        """
        this = _algorithms.new_Cells4(*args, **kwargs)
        try: self.this.append(this)
        except: self.this = this
    def initialize(*args, **kwargs):
        """
        initialize(self, nColumns=0, nCellsPerCol=0, activationThreshold=1, 
            minThreshold=1, newSynapseCount=1, segUpdateValidDuration=1, 
            permInitial=.5, permConnected=.8, 
            permMax=1, permDec=.1, permInc=.1, globalDecay=.1, 
            doPooling=False, doItAll=False, checkSynapseConsistency=False)
        """
        return _algorithms.Cells4_initialize(*args, **kwargs)

    __swig_destroy__ = _algorithms.delete_Cells4
    def version(*args, **kwargs):
        """version(self) -> UInt"""
        return _algorithms.Cells4_version(*args, **kwargs)

    def getStatePointers(*args, **kwargs):
        """
        getStatePointers(self, activeT, activeT1, predT, predT1, colConfidenceT, colConfidenceT1, 
            confidenceT, confidenceT1)
        """
        return _algorithms.Cells4_getStatePointers(*args, **kwargs)

    def getLearnStatePointers(*args, **kwargs):
        """getLearnStatePointers(self, activeT, activeT1, predT, predT1)"""
        return _algorithms.Cells4_getLearnStatePointers(*args, **kwargs)

    def nSegments(*args, **kwargs):
        """nSegments(self) -> UInt"""
        return _algorithms.Cells4_nSegments(*args, **kwargs)

    def nCells(*args, **kwargs):
        """nCells(self) -> UInt"""
        return _algorithms.Cells4_nCells(*args, **kwargs)

    def nColumns(*args, **kwargs):
        """nColumns(self) -> UInt"""
        return _algorithms.Cells4_nColumns(*args, **kwargs)

    def nCellsPerCol(*args, **kwargs):
        """nCellsPerCol(self) -> UInt"""
        return _algorithms.Cells4_nCellsPerCol(*args, **kwargs)

    def getMinThreshold(*args, **kwargs):
        """getMinThreshold(self) -> UInt"""
        return _algorithms.Cells4_getMinThreshold(*args, **kwargs)

    def getPermConnected(*args, **kwargs):
        """getPermConnected(self) -> Real"""
        return _algorithms.Cells4_getPermConnected(*args, **kwargs)

    def getVerbosity(*args, **kwargs):
        """getVerbosity(self) -> UInt"""
        return _algorithms.Cells4_getVerbosity(*args, **kwargs)

    def getMaxAge(*args, **kwargs):
        """getMaxAge(self) -> UInt"""
        return _algorithms.Cells4_getMaxAge(*args, **kwargs)

    def getPamLength(*args, **kwargs):
        """getPamLength(self) -> UInt"""
        return _algorithms.Cells4_getPamLength(*args, **kwargs)

    def getMaxInfBacktrack(*args, **kwargs):
        """getMaxInfBacktrack(self) -> UInt"""
        return _algorithms.Cells4_getMaxInfBacktrack(*args, **kwargs)

    def getMaxLrnBacktrack(*args, **kwargs):
        """getMaxLrnBacktrack(self) -> UInt"""
        return _algorithms.Cells4_getMaxLrnBacktrack(*args, **kwargs)

    def getPamCounter(*args, **kwargs):
        """getPamCounter(self) -> UInt"""
        return _algorithms.Cells4_getPamCounter(*args, **kwargs)

    def getMaxSeqLength(*args, **kwargs):
        """getMaxSeqLength(self) -> UInt"""
        return _algorithms.Cells4_getMaxSeqLength(*args, **kwargs)

    def getAvgLearnedSeqLength(*args, **kwargs):
        """getAvgLearnedSeqLength(self) -> Real"""
        return _algorithms.Cells4_getAvgLearnedSeqLength(*args, **kwargs)

    def getNLrnIterations(*args, **kwargs):
        """getNLrnIterations(self) -> UInt"""
        return _algorithms.Cells4_getNLrnIterations(*args, **kwargs)

    def getmaxSegmentsPerCell(*args, **kwargs):
        """getmaxSegmentsPerCell(self) -> Int"""
        return _algorithms.Cells4_getmaxSegmentsPerCell(*args, **kwargs)

    def getMaxSynapsesPerCell(*args, **kwargs):
        """getMaxSynapsesPerCell(self) -> Int"""
        return _algorithms.Cells4_getMaxSynapsesPerCell(*args, **kwargs)

    def getCheckSynapseConsistency(*args, **kwargs):
        """getCheckSynapseConsistency(self) -> bool"""
        return _algorithms.Cells4_getCheckSynapseConsistency(*args, **kwargs)

    def setMaxInfBacktrack(*args, **kwargs):
        """setMaxInfBacktrack(self, t)"""
        return _algorithms.Cells4_setMaxInfBacktrack(*args, **kwargs)

    def setMaxLrnBacktrack(*args, **kwargs):
        """setMaxLrnBacktrack(self, t)"""
        return _algorithms.Cells4_setMaxLrnBacktrack(*args, **kwargs)

    def setVerbosity(*args, **kwargs):
        """setVerbosity(self, v)"""
        return _algorithms.Cells4_setVerbosity(*args, **kwargs)

    def setMaxAge(*args, **kwargs):
        """setMaxAge(self, a)"""
        return _algorithms.Cells4_setMaxAge(*args, **kwargs)

    def setMaxSeqLength(*args, **kwargs):
        """setMaxSeqLength(self, v)"""
        return _algorithms.Cells4_setMaxSeqLength(*args, **kwargs)

    def setCheckSynapseConsistency(*args, **kwargs):
        """setCheckSynapseConsistency(self, val)"""
        return _algorithms.Cells4_setCheckSynapseConsistency(*args, **kwargs)

    def setMaxSegmentsPerCell(*args, **kwargs):
        """setMaxSegmentsPerCell(self, maxSegs)"""
        return _algorithms.Cells4_setMaxSegmentsPerCell(*args, **kwargs)

    def setMaxSynapsesPerCell(*args, **kwargs):
        """setMaxSynapsesPerCell(self, maxSyns)"""
        return _algorithms.Cells4_setMaxSynapsesPerCell(*args, **kwargs)

    def setPamLength(*args, **kwargs):
        """setPamLength(self, pl)"""
        return _algorithms.Cells4_setPamLength(*args, **kwargs)

    def nSegmentsOnCell(*args, **kwargs):
        """nSegmentsOnCell(self, colIdx, cellIdxInCol) -> UInt"""
        return _algorithms.Cells4_nSegmentsOnCell(*args, **kwargs)

    def nSynapses(*args, **kwargs):
        """nSynapses(self) -> UInt"""
        return _algorithms.Cells4_nSynapses(*args, **kwargs)

    def __nSegmentsOnCell(*args, **kwargs):
        """__nSegmentsOnCell(self, cellIdx) -> UInt"""
        return _algorithms.Cells4___nSegmentsOnCell(*args, **kwargs)

    def nSynapsesInCell(*args, **kwargs):
        """nSynapsesInCell(self, cellIdx) -> UInt"""
        return _algorithms.Cells4_nSynapsesInCell(*args, **kwargs)

    def getCell(*args, **kwargs):
        """getCell(self, colIdx, cellIdxInCol) -> Cell"""
        return _algorithms.Cells4_getCell(*args, **kwargs)

    def getCellIdx(*args, **kwargs):
        """getCellIdx(self, colIdx, cellIdxInCol) -> UInt"""
        return _algorithms.Cells4_getCellIdx(*args, **kwargs)

    def getSegment(*args, **kwargs):
        """getSegment(self, colIdx, cellIdxInCol, segIdx) -> Segment"""
        return _algorithms.Cells4_getSegment(*args, **kwargs)

    def segment(*args, **kwargs):
        """segment(self, cellIdx, segIdx) -> Segment"""
        return _algorithms.Cells4_segment(*args, **kwargs)

    def reset(*args, **kwargs):
        """reset(self)"""
        return _algorithms.Cells4_reset(*args, **kwargs)

    def isActive(*args, **kwargs):
        """isActive(self, cellIdx, segIdx, state) -> bool"""
        return _algorithms.Cells4_isActive(*args, **kwargs)

    def getBestMatchingCellT(*args, **kwargs):
        """getBestMatchingCellT(self, colIdx, state, minThreshold) -> std::pair<(nta::UInt,nta::UInt)>"""
        return _algorithms.Cells4_getBestMatchingCellT(*args, **kwargs)

    def getBestMatchingCellT1(*args, **kwargs):
        """getBestMatchingCellT1(self, colIdx, state, minThreshold) -> std::pair<(nta::UInt,nta::UInt)>"""
        return _algorithms.Cells4_getBestMatchingCellT1(*args, **kwargs)

    def computeForwardPropagation(*args):
        """
        computeForwardPropagation(self, state)
        computeForwardPropagation(self, state)
        """
        return _algorithms.Cells4_computeForwardPropagation(*args)

    def updateInferenceState(*args, **kwargs):
        """updateInferenceState(self, activeColumns)"""
        return _algorithms.Cells4_updateInferenceState(*args, **kwargs)

    def inferPhase1(*args, **kwargs):
        """inferPhase1(self, activeColumns, useStartCells) -> bool"""
        return _algorithms.Cells4_inferPhase1(*args, **kwargs)

    def inferPhase2(*args, **kwargs):
        """inferPhase2(self) -> bool"""
        return _algorithms.Cells4_inferPhase2(*args, **kwargs)

    def inferBacktrack(*args, **kwargs):
        """inferBacktrack(self, activeColumns)"""
        return _algorithms.Cells4_inferBacktrack(*args, **kwargs)

    def updateLearningState(*args, **kwargs):
        """updateLearningState(self, activeColumns, input)"""
        return _algorithms.Cells4_updateLearningState(*args, **kwargs)

    def learnPhase1(*args, **kwargs):
        """learnPhase1(self, activeColumns, readOnly) -> bool"""
        return _algorithms.Cells4_learnPhase1(*args, **kwargs)

    def learnPhase2(*args, **kwargs):
        """learnPhase2(self, readOnly)"""
        return _algorithms.Cells4_learnPhase2(*args, **kwargs)

    def learnBacktrack(*args, **kwargs):
        """learnBacktrack(self) -> UInt"""
        return _algorithms.Cells4_learnBacktrack(*args, **kwargs)

    def learnBacktrackFrom(*args, **kwargs):
        """learnBacktrackFrom(self, startOffset, readOnly) -> bool"""
        return _algorithms.Cells4_learnBacktrackFrom(*args, **kwargs)

    def _updateAvgLearnedSeqLength(*args, **kwargs):
        """_updateAvgLearnedSeqLength(self, prevSeqLength)"""
        return _algorithms.Cells4__updateAvgLearnedSeqLength(*args, **kwargs)

    def chooseCellsToLearnFrom(*args, **kwargs):
        """chooseCellsToLearnFrom(self, cellIdx, segIdx, nSynToAdd, state, srcCells)"""
        return _algorithms.Cells4_chooseCellsToLearnFrom(*args, **kwargs)

    def getCellForNewSegment(*args, **kwargs):
        """getCellForNewSegment(self, colIdx) -> UInt"""
        return _algorithms.Cells4_getCellForNewSegment(*args, **kwargs)

    def computeUpdate(*args, **kwargs):
        """
        computeUpdate(self, cellIdx, segIdx, activeState, sequenceSegmentFlag, 
            newSynapsesFlag) -> bool
        """
        return _algorithms.Cells4_computeUpdate(*args, **kwargs)

    def eraseOutSynapses(*args, **kwargs):
        """eraseOutSynapses(self, dstCellIdx, dstSegIdx, srcCells)"""
        return _algorithms.Cells4_eraseOutSynapses(*args, **kwargs)

    def processSegmentUpdates(*args, **kwargs):
        """processSegmentUpdates(self, input, predictedState)"""
        return _algorithms.Cells4_processSegmentUpdates(*args, **kwargs)

    def cleanUpdatesList(*args, **kwargs):
        """cleanUpdatesList(self, cellIdx, segIdx)"""
        return _algorithms.Cells4_cleanUpdatesList(*args, **kwargs)

    def applyGlobalDecay(*args, **kwargs):
        """applyGlobalDecay(self)"""
        return _algorithms.Cells4_applyGlobalDecay(*args, **kwargs)

    def adaptSegment(*args, **kwargs):
        """adaptSegment(self, update)"""
        return _algorithms.Cells4_adaptSegment(*args, **kwargs)

    def trimSegments(*args, **kwargs):
        """trimSegments(self, minPermanence, minNumSyns) -> std::pair<(nta::UInt,nta::UInt)>"""
        return _algorithms.Cells4_trimSegments(*args, **kwargs)

    def persistentSize(*args, **kwargs):
        """persistentSize(self) -> UInt"""
        return _algorithms.Cells4_persistentSize(*args, **kwargs)

    def saveToFile(*args, **kwargs):
        """saveToFile(self, filePath)"""
        return _algorithms.Cells4_saveToFile(*args, **kwargs)

    def loadFromFile(*args, **kwargs):
        """loadFromFile(self, filePath)"""
        return _algorithms.Cells4_loadFromFile(*args, **kwargs)

    def save(*args, **kwargs):
        """save(self, outStream)"""
        return _algorithms.Cells4_save(*args, **kwargs)

    def load(*args, **kwargs):
        """load(self, inStream)"""
        return _algorithms.Cells4_load(*args, **kwargs)

    def setCellSegmentOrder(*args, **kwargs):
        """setCellSegmentOrder(self, matchPythonOrder)"""
        return _algorithms.Cells4_setCellSegmentOrder(*args, **kwargs)

    def addNewSegment(*args, **kwargs):
        """addNewSegment(self, colIdx, cellIdxInCol, sequenceSegmentFlag, extSynapses)"""
        return _algorithms.Cells4_addNewSegment(*args, **kwargs)

    def updateSegment(*args, **kwargs):
        """updateSegment(self, colIdx, cellIdxInCol, segIdx, extSynapses)"""
        return _algorithms.Cells4_updateSegment(*args, **kwargs)

    def _rebalance(*args, **kwargs):
        """_rebalance(self)"""
        return _algorithms.Cells4__rebalance(*args, **kwargs)

    def rebuildOutSynapses(*args, **kwargs):
        """rebuildOutSynapses(self)"""
        return _algorithms.Cells4_rebuildOutSynapses(*args, **kwargs)

    def trimOldSegments(*args, **kwargs):
        """trimOldSegments(self, age)"""
        return _algorithms.Cells4_trimOldSegments(*args, **kwargs)

    def printStates(*args, **kwargs):
        """printStates(self)"""
        return _algorithms.Cells4_printStates(*args, **kwargs)

    def printState(*args, **kwargs):
        """printState(self, state)"""
        return _algorithms.Cells4_printState(*args, **kwargs)

    def dumpPrevPatterns(*args, **kwargs):
        """dumpPrevPatterns(self, patterns)"""
        return _algorithms.Cells4_dumpPrevPatterns(*args, **kwargs)

    def dumpSegmentUpdates(*args, **kwargs):
        """dumpSegmentUpdates(self)"""
        return _algorithms.Cells4_dumpSegmentUpdates(*args, **kwargs)

    def getNonEmptySegList(*args, **kwargs):
        """getNonEmptySegList(self, colIdx, cellIdxInCol) -> std::vector<(nta::UInt,std::allocator<(nta::UInt)>)>"""
        return _algorithms.Cells4_getNonEmptySegList(*args, **kwargs)

    def dumpTiming(*args, **kwargs):
        """dumpTiming(self)"""
        return _algorithms.Cells4_dumpTiming(*args, **kwargs)

    def resetTimers(*args, **kwargs):
        """resetTimers(self)"""
        return _algorithms.Cells4_resetTimers(*args, **kwargs)

    def invariants(*args, **kwargs):
        """invariants(self, verbose=False) -> bool"""
        return _algorithms.Cells4_invariants(*args, **kwargs)

    def stats(*args, **kwargs):
        """stats(self)"""
        return _algorithms.Cells4_stats(*args, **kwargs)

    def __init__(self, *args, **kwargs):
      self.this = _ALGORITHMS.new_Cells4(*args, **kwargs)

    def __setstate__(self, inString):
      self.this = _ALGORITHMS.new_Cells4()
      self.loadFromString(inString)

    def loadFromString(*args, **kwargs):
        """loadFromString(self, inString)"""
        return _algorithms.Cells4_loadFromString(*args, **kwargs)

    def __getstate__(*args, **kwargs):
        """__getstate__(self) -> PyObject"""
        return _algorithms.Cells4___getstate__(*args, **kwargs)

    def setStatePointers(*args):
        """
        setStatePointers(self, infActiveT, infActiveT1, infPredT, infPredT1, colConfidenceT, 
            colConfidenceT1, cellConfidenceT, 
            cellConfidenceT1)
        setStatePointers(self, py_infActiveStateT, py_infActiveStateT1, py_infPredictedStateT, 
            py_infPredictedStateT1, py_colConfidenceT, 
            py_colConfidenceT1, py_cellConfidenceT, 
            py_cellConfidenceT1)
        """
        return _algorithms.Cells4_setStatePointers(*args)

    def getStates(*args, **kwargs):
        """getStates(self) -> PyObject"""
        return _algorithms.Cells4_getStates(*args, **kwargs)

    def getLearnStates(*args, **kwargs):
        """getLearnStates(self) -> PyObject"""
        return _algorithms.Cells4_getLearnStates(*args, **kwargs)

    def compute(*args):
        """
        compute(self, input, output, doInference, doLearning)
        compute(self, py_x, doInference, doLearning) -> PyObject
        """
        return _algorithms.Cells4_compute(*args)

Cells4_swigregister = _algorithms.Cells4_swigregister
Cells4_swigregister(Cells4)
_MAX_CELLS = cvar._MAX_CELLS
_MAX_SEGS = cvar._MAX_SEGS

class SpatialPooler(object):
    """Proxy of C++ SpatialPooler class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args, **kwargs): 
        """__init__(self) -> SpatialPooler"""
        this = _algorithms.new_SpatialPooler(*args, **kwargs)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _algorithms.delete_SpatialPooler
    def version(*args, **kwargs):
        """version(self) -> UInt"""
        return _algorithms.SpatialPooler_version(*args, **kwargs)

    def save(*args, **kwargs):
        """save(self, outStream)"""
        return _algorithms.SpatialPooler_save(*args, **kwargs)

    def load(*args, **kwargs):
        """load(self, inStream)"""
        return _algorithms.SpatialPooler_load(*args, **kwargs)

    def persistentSize(*args, **kwargs):
        """persistentSize(self) -> UInt"""
        return _algorithms.SpatialPooler_persistentSize(*args, **kwargs)

    def getNumColumns(*args, **kwargs):
        """getNumColumns(self) -> UInt"""
        return _algorithms.SpatialPooler_getNumColumns(*args, **kwargs)

    def getNumInputs(*args, **kwargs):
        """getNumInputs(self) -> UInt"""
        return _algorithms.SpatialPooler_getNumInputs(*args, **kwargs)

    def getPotentialRadius(*args, **kwargs):
        """getPotentialRadius(self) -> UInt"""
        return _algorithms.SpatialPooler_getPotentialRadius(*args, **kwargs)

    def setPotentialRadius(*args, **kwargs):
        """setPotentialRadius(self, potentialRadius)"""
        return _algorithms.SpatialPooler_setPotentialRadius(*args, **kwargs)

    def getPotentialPct(*args, **kwargs):
        """getPotentialPct(self) -> Real"""
        return _algorithms.SpatialPooler_getPotentialPct(*args, **kwargs)

    def setPotentialPct(*args, **kwargs):
        """setPotentialPct(self, potentialPct)"""
        return _algorithms.SpatialPooler_setPotentialPct(*args, **kwargs)

    def getGlobalInhibition(*args, **kwargs):
        """getGlobalInhibition(self) -> bool"""
        return _algorithms.SpatialPooler_getGlobalInhibition(*args, **kwargs)

    def setGlobalInhibition(*args, **kwargs):
        """setGlobalInhibition(self, globalInhibition)"""
        return _algorithms.SpatialPooler_setGlobalInhibition(*args, **kwargs)

    def getNumActiveColumnsPerInhArea(*args, **kwargs):
        """getNumActiveColumnsPerInhArea(self) -> Int"""
        return _algorithms.SpatialPooler_getNumActiveColumnsPerInhArea(*args, **kwargs)

    def setNumActiveColumnsPerInhArea(*args, **kwargs):
        """setNumActiveColumnsPerInhArea(self, numActiveColumnsPerInhArea)"""
        return _algorithms.SpatialPooler_setNumActiveColumnsPerInhArea(*args, **kwargs)

    def getLocalAreaDensity(*args, **kwargs):
        """getLocalAreaDensity(self) -> Real"""
        return _algorithms.SpatialPooler_getLocalAreaDensity(*args, **kwargs)

    def setLocalAreaDensity(*args, **kwargs):
        """setLocalAreaDensity(self, localAreaDensity)"""
        return _algorithms.SpatialPooler_setLocalAreaDensity(*args, **kwargs)

    def getStimulusThreshold(*args, **kwargs):
        """getStimulusThreshold(self) -> UInt"""
        return _algorithms.SpatialPooler_getStimulusThreshold(*args, **kwargs)

    def setStimulusThreshold(*args, **kwargs):
        """setStimulusThreshold(self, stimulusThreshold)"""
        return _algorithms.SpatialPooler_setStimulusThreshold(*args, **kwargs)

    def getInhibitionRadius(*args, **kwargs):
        """getInhibitionRadius(self) -> UInt"""
        return _algorithms.SpatialPooler_getInhibitionRadius(*args, **kwargs)

    def setInhibitionRadius(*args, **kwargs):
        """setInhibitionRadius(self, inhibitionRadius)"""
        return _algorithms.SpatialPooler_setInhibitionRadius(*args, **kwargs)

    def getDutyCyclePeriod(*args, **kwargs):
        """getDutyCyclePeriod(self) -> UInt"""
        return _algorithms.SpatialPooler_getDutyCyclePeriod(*args, **kwargs)

    def setDutyCyclePeriod(*args, **kwargs):
        """setDutyCyclePeriod(self, dutyCyclePeriod)"""
        return _algorithms.SpatialPooler_setDutyCyclePeriod(*args, **kwargs)

    def getMaxBoost(*args, **kwargs):
        """getMaxBoost(self) -> Real"""
        return _algorithms.SpatialPooler_getMaxBoost(*args, **kwargs)

    def setMaxBoost(*args, **kwargs):
        """setMaxBoost(self, maxBoost)"""
        return _algorithms.SpatialPooler_setMaxBoost(*args, **kwargs)

    def getIterationNum(*args, **kwargs):
        """getIterationNum(self) -> UInt"""
        return _algorithms.SpatialPooler_getIterationNum(*args, **kwargs)

    def setIterationNum(*args, **kwargs):
        """setIterationNum(self, iterationNum)"""
        return _algorithms.SpatialPooler_setIterationNum(*args, **kwargs)

    def getIterationLearnNum(*args, **kwargs):
        """getIterationLearnNum(self) -> UInt"""
        return _algorithms.SpatialPooler_getIterationLearnNum(*args, **kwargs)

    def setIterationLearnNum(*args, **kwargs):
        """setIterationLearnNum(self, iterationLearnNum)"""
        return _algorithms.SpatialPooler_setIterationLearnNum(*args, **kwargs)

    def getSpVerbosity(*args, **kwargs):
        """getSpVerbosity(self) -> UInt"""
        return _algorithms.SpatialPooler_getSpVerbosity(*args, **kwargs)

    def setSpVerbosity(*args, **kwargs):
        """setSpVerbosity(self, spVerbosity)"""
        return _algorithms.SpatialPooler_setSpVerbosity(*args, **kwargs)

    def getUpdatePeriod(*args, **kwargs):
        """getUpdatePeriod(self) -> UInt"""
        return _algorithms.SpatialPooler_getUpdatePeriod(*args, **kwargs)

    def setUpdatePeriod(*args, **kwargs):
        """setUpdatePeriod(self, updatePeriod)"""
        return _algorithms.SpatialPooler_setUpdatePeriod(*args, **kwargs)

    def getSynPermTrimThreshold(*args, **kwargs):
        """getSynPermTrimThreshold(self) -> Real"""
        return _algorithms.SpatialPooler_getSynPermTrimThreshold(*args, **kwargs)

    def setSynPermTrimThreshold(*args, **kwargs):
        """setSynPermTrimThreshold(self, synPermTrimThreshold)"""
        return _algorithms.SpatialPooler_setSynPermTrimThreshold(*args, **kwargs)

    def getSynPermActiveInc(*args, **kwargs):
        """getSynPermActiveInc(self) -> Real"""
        return _algorithms.SpatialPooler_getSynPermActiveInc(*args, **kwargs)

    def setSynPermActiveInc(*args, **kwargs):
        """setSynPermActiveInc(self, synPermActiveInc)"""
        return _algorithms.SpatialPooler_setSynPermActiveInc(*args, **kwargs)

    def getSynPermInactiveDec(*args, **kwargs):
        """getSynPermInactiveDec(self) -> Real"""
        return _algorithms.SpatialPooler_getSynPermInactiveDec(*args, **kwargs)

    def setSynPermInactiveDec(*args, **kwargs):
        """setSynPermInactiveDec(self, synPermInactiveDec)"""
        return _algorithms.SpatialPooler_setSynPermInactiveDec(*args, **kwargs)

    def getSynPermBelowStimulusInc(*args, **kwargs):
        """getSynPermBelowStimulusInc(self) -> Real"""
        return _algorithms.SpatialPooler_getSynPermBelowStimulusInc(*args, **kwargs)

    def setSynPermBelowStimulusInc(*args, **kwargs):
        """setSynPermBelowStimulusInc(self, synPermBelowStimulusInc)"""
        return _algorithms.SpatialPooler_setSynPermBelowStimulusInc(*args, **kwargs)

    def getSynPermConnected(*args, **kwargs):
        """getSynPermConnected(self) -> Real"""
        return _algorithms.SpatialPooler_getSynPermConnected(*args, **kwargs)

    def setSynPermConnected(*args, **kwargs):
        """setSynPermConnected(self, setSynPermConnected)"""
        return _algorithms.SpatialPooler_setSynPermConnected(*args, **kwargs)

    def getMinPctOverlapDutyCycles(*args, **kwargs):
        """getMinPctOverlapDutyCycles(self) -> Real"""
        return _algorithms.SpatialPooler_getMinPctOverlapDutyCycles(*args, **kwargs)

    def setMinPctOverlapDutyCycles(*args, **kwargs):
        """setMinPctOverlapDutyCycles(self, minPctOverlapDutyCycles)"""
        return _algorithms.SpatialPooler_setMinPctOverlapDutyCycles(*args, **kwargs)

    def getMinPctActiveDutyCycles(*args, **kwargs):
        """getMinPctActiveDutyCycles(self) -> Real"""
        return _algorithms.SpatialPooler_getMinPctActiveDutyCycles(*args, **kwargs)

    def setMinPctActiveDutyCycles(*args, **kwargs):
        """setMinPctActiveDutyCycles(self, minPctActiveDutyCycles)"""
        return _algorithms.SpatialPooler_setMinPctActiveDutyCycles(*args, **kwargs)

    def stripNeverLearned_(*args, **kwargs):
        """stripNeverLearned_(self, activeArray)"""
        return _algorithms.SpatialPooler_stripNeverLearned_(*args, **kwargs)

    def toDense_(*args, **kwargs):
        """toDense_(self, sparse, dense, n)"""
        return _algorithms.SpatialPooler_toDense_(*args, **kwargs)

    def boostOverlaps_(*args, **kwargs):
        """boostOverlaps_(self, overlaps, boostedOverlaps)"""
        return _algorithms.SpatialPooler_boostOverlaps_(*args, **kwargs)

    def range_(*args, **kwargs):
        """range_(self, start, end, ubound, wrapAround, rangeVector)"""
        return _algorithms.SpatialPooler_range_(*args, **kwargs)

    def mapPotential1D_(*args, **kwargs):
        """mapPotential1D_(self, column, wrapAround) -> std::vector<(nta::UInt)>"""
        return _algorithms.SpatialPooler_mapPotential1D_(*args, **kwargs)

    def initPermConnected_(*args, **kwargs):
        """initPermConnected_(self) -> Real"""
        return _algorithms.SpatialPooler_initPermConnected_(*args, **kwargs)

    def initPermNonConnected_(*args, **kwargs):
        """initPermNonConnected_(self) -> Real"""
        return _algorithms.SpatialPooler_initPermNonConnected_(*args, **kwargs)

    def initPermanence_(*args, **kwargs):
        """initPermanence_(self, potential, connectedPct) -> std::vector<(nta::Real)>"""
        return _algorithms.SpatialPooler_initPermanence_(*args, **kwargs)

    def clip_(*args, **kwargs):
        """clip_(self, perm, trim)"""
        return _algorithms.SpatialPooler_clip_(*args, **kwargs)

    def updatePermanencesForColumn_(*args, **kwargs):
        """updatePermanencesForColumn_(self, perm, column, raisePerm=True)"""
        return _algorithms.SpatialPooler_updatePermanencesForColumn_(*args, **kwargs)

    def countConnected_(*args, **kwargs):
        """countConnected_(self, perm) -> UInt"""
        return _algorithms.SpatialPooler_countConnected_(*args, **kwargs)

    def raisePermanencesToThreshold_(*args, **kwargs):
        """raisePermanencesToThreshold_(self, perm, potential) -> UInt"""
        return _algorithms.SpatialPooler_raisePermanencesToThreshold_(*args, **kwargs)

    def calculateOverlap_(*args, **kwargs):
        """calculateOverlap_(self, inputVector, overlap)"""
        return _algorithms.SpatialPooler_calculateOverlap_(*args, **kwargs)

    def calculateOverlapPct_(*args, **kwargs):
        """calculateOverlapPct_(self, overlaps, overlapPct)"""
        return _algorithms.SpatialPooler_calculateOverlapPct_(*args, **kwargs)

    def isWinner_(*args, **kwargs):
        """isWinner_(self, score, winners, numWinners) -> bool"""
        return _algorithms.SpatialPooler_isWinner_(*args, **kwargs)

    def addToWinners_(*args, **kwargs):
        """addToWinners_(self, index, score, winners)"""
        return _algorithms.SpatialPooler_addToWinners_(*args, **kwargs)

    def inhibitColumns_(*args, **kwargs):
        """inhibitColumns_(self, overlaps, activeColumns)"""
        return _algorithms.SpatialPooler_inhibitColumns_(*args, **kwargs)

    def inhibitColumnsGlobal_(*args, **kwargs):
        """inhibitColumnsGlobal_(self, overlaps, density, activeColumns)"""
        return _algorithms.SpatialPooler_inhibitColumnsGlobal_(*args, **kwargs)

    def inhibitColumnsLocal_(*args, **kwargs):
        """inhibitColumnsLocal_(self, overlaps, density, activeColumns)"""
        return _algorithms.SpatialPooler_inhibitColumnsLocal_(*args, **kwargs)

    def getNeighbors1D_(*args, **kwargs):
        """getNeighbors1D_(self, column, dimensions, radius, wrapAround, neighbors)"""
        return _algorithms.SpatialPooler_getNeighbors1D_(*args, **kwargs)

    def getNeighbors2D_(*args, **kwargs):
        """getNeighbors2D_(self, column, dimensions, radius, wrapAround, neighbors)"""
        return _algorithms.SpatialPooler_getNeighbors2D_(*args, **kwargs)

    def cartesianProduct_(*args, **kwargs):
        """cartesianProduct_(self, vecs, product)"""
        return _algorithms.SpatialPooler_cartesianProduct_(*args, **kwargs)

    def getNeighborsND_(*args, **kwargs):
        """getNeighborsND_(self, column, dimensions, radius, wrapAround, neighbors)"""
        return _algorithms.SpatialPooler_getNeighborsND_(*args, **kwargs)

    def adaptSynapses_(*args, **kwargs):
        """adaptSynapses_(self, inputVector, activeColumns)"""
        return _algorithms.SpatialPooler_adaptSynapses_(*args, **kwargs)

    def bumpUpWeakColumns_(*args, **kwargs):
        """bumpUpWeakColumns_(self)"""
        return _algorithms.SpatialPooler_bumpUpWeakColumns_(*args, **kwargs)

    def updateInhibitionRadius_(*args, **kwargs):
        """updateInhibitionRadius_(self)"""
        return _algorithms.SpatialPooler_updateInhibitionRadius_(*args, **kwargs)

    def avgColumnsPerInput_(*args, **kwargs):
        """avgColumnsPerInput_(self) -> Real"""
        return _algorithms.SpatialPooler_avgColumnsPerInput_(*args, **kwargs)

    def avgConnectedSpanForColumn1D_(*args, **kwargs):
        """avgConnectedSpanForColumn1D_(self, column) -> Real"""
        return _algorithms.SpatialPooler_avgConnectedSpanForColumn1D_(*args, **kwargs)

    def avgConnectedSpanForColumn2D_(*args, **kwargs):
        """avgConnectedSpanForColumn2D_(self, column) -> Real"""
        return _algorithms.SpatialPooler_avgConnectedSpanForColumn2D_(*args, **kwargs)

    def avgConnectedSpanForColumnND_(*args, **kwargs):
        """avgConnectedSpanForColumnND_(self, column) -> Real"""
        return _algorithms.SpatialPooler_avgConnectedSpanForColumnND_(*args, **kwargs)

    def updateMinDutyCycles_(*args, **kwargs):
        """updateMinDutyCycles_(self)"""
        return _algorithms.SpatialPooler_updateMinDutyCycles_(*args, **kwargs)

    def updateMinDutyCyclesGlobal_(*args, **kwargs):
        """updateMinDutyCyclesGlobal_(self)"""
        return _algorithms.SpatialPooler_updateMinDutyCyclesGlobal_(*args, **kwargs)

    def updateMinDutyCyclesLocal_(*args, **kwargs):
        """updateMinDutyCyclesLocal_(self)"""
        return _algorithms.SpatialPooler_updateMinDutyCyclesLocal_(*args, **kwargs)

    def updateDutyCyclesHelper_(*args, **kwargs):
        """updateDutyCyclesHelper_(dutyCycles, newValues, period)"""
        return _algorithms.SpatialPooler_updateDutyCyclesHelper_(*args, **kwargs)

    updateDutyCyclesHelper_ = staticmethod(updateDutyCyclesHelper_)
    def updateDutyCycles_(*args, **kwargs):
        """updateDutyCycles_(self, overlaps, activeArray)"""
        return _algorithms.SpatialPooler_updateDutyCycles_(*args, **kwargs)

    def updateBoostFactors_(*args, **kwargs):
        """updateBoostFactors_(self)"""
        return _algorithms.SpatialPooler_updateBoostFactors_(*args, **kwargs)

    def updateBookeepingVars_(*args, **kwargs):
        """updateBookeepingVars_(self, learn)"""
        return _algorithms.SpatialPooler_updateBookeepingVars_(*args, **kwargs)

    def isUpdateRound_(*args, **kwargs):
        """isUpdateRound_(self) -> bool"""
        return _algorithms.SpatialPooler_isUpdateRound_(*args, **kwargs)

    def initialize(*args, **kwargs):
        """
        initialize(self, inputDimensions, columnDimensions, potentialRadius=16, 
            potentialPct=0.5, globalInhibition=True, 
            localAreaDensity=-1.0, numActiveColumnsPerInhArea=10, 
            stimulusThreshold=0, synPermInactiveDec=0.01, 
            synPermActiveInc=0.1, synPermConnected=0.1, 
            minPctOverlapDutyCycles=0.001, minPctActiveDutyCycles=0.001, 
            dutyCyclePeriod=1000, 
            maxBoost=10.0, seed=1, spVerbosity=0)
        """
        return _algorithms.SpatialPooler_initialize(*args, **kwargs)

    def seed_(*args, **kwargs):
        """seed_(self, seed)"""
        return _algorithms.SpatialPooler_seed_(*args, **kwargs)

    import numpy
    from nupic.bindings.math import (SM32 as SparseMatrix,
                                     SM_01_32_32 as SparseBinaryMatrix)

    def __init__(self,
                 inputDimensions=[32,32],
                 columnDimensions=[64,64],
                 potentialRadius=16,
                 potentialPct=0.5,
                 globalInhibition=False,
                 localAreaDensity=-1.0,
                 numActiveColumnsPerInhArea=10.0,
                 stimulusThreshold=0,
                 synPermInactiveDec=0.01,
                 synPermActiveInc=0.1,
                 synPermConnected=0.10,
                 minPctOverlapDutyCycle=0.001,
                 minPctActiveDutyCycle=0.001,
                 dutyCyclePeriod=1000,
                 maxBoost=10.0,
                 seed=-1,
                 spVerbosity=0):
      self.this = _ALGORITHMS.new_SpatialPooler()
      _ALGORITHMS.SpatialPooler_initialize(
        self, inputDimensions, columnDimensions, potentialRadius, potentialPct, 
        globalInhibition, localAreaDensity, numActiveColumnsPerInhArea, 
        stimulusThreshold, synPermInactiveDec, synPermActiveInc, synPermConnected, 
        minPctOverlapDutyCycle, minPctActiveDutyCycle, dutyCyclePeriod, maxBoost, 
        seed, spVerbosity)

    def __getstate__(self):
      # Save the local attributes but override the C++ spatial pooler with the
      # string representation.
      d = dict(self.__dict__)
      d["this"] = self.getCState()
      return d

    def __setstate__(self, state):
      # Create an empty C++ spatial pooler and populate it from the serialized
      # string.
      self.this = _ALGORITHMS.new_SpatialPooler()
      if isinstance(state, str):
        self.loadFromString(state)
        self.valueToCategory = {}
      else:
        self.loadFromString(state["this"])
        # Use the rest of the state to set local Python attributes.
        del state["this"]
        self.__dict__.update(state)

    def compute(*args):
        """
        compute(self, inputVector, learn, activeVector)
        compute(self, py_x, learn, py_y) -> UInt
        """
        return _algorithms.SpatialPooler_compute(*args)

    def loadFromString(*args, **kwargs):
        """loadFromString(self, inString)"""
        return _algorithms.SpatialPooler_loadFromString(*args, **kwargs)

    def getCState(*args, **kwargs):
        """getCState(self) -> PyObject"""
        return _algorithms.SpatialPooler_getCState(*args, **kwargs)

    def setBoostFactors(*args):
        """
        setBoostFactors(self, boostFactors)
        setBoostFactors(self, py_x)
        """
        return _algorithms.SpatialPooler_setBoostFactors(*args)

    def getBoostFactors(*args):
        """
        getBoostFactors(self, boostFactors)
        getBoostFactors(self, py_x)
        """
        return _algorithms.SpatialPooler_getBoostFactors(*args)

    def setOverlapDutyCycles(*args):
        """
        setOverlapDutyCycles(self, overlapDutyCycles)
        setOverlapDutyCycles(self, py_x)
        """
        return _algorithms.SpatialPooler_setOverlapDutyCycles(*args)

    def getOverlapDutyCycles(*args):
        """
        getOverlapDutyCycles(self, overlapDutyCycles)
        getOverlapDutyCycles(self, py_x)
        """
        return _algorithms.SpatialPooler_getOverlapDutyCycles(*args)

    def setActiveDutyCycles(*args):
        """
        setActiveDutyCycles(self, activeDutyCycles)
        setActiveDutyCycles(self, py_x)
        """
        return _algorithms.SpatialPooler_setActiveDutyCycles(*args)

    def getActiveDutyCycles(*args):
        """
        getActiveDutyCycles(self, activeDutyCycles)
        getActiveDutyCycles(self, py_x)
        """
        return _algorithms.SpatialPooler_getActiveDutyCycles(*args)

    def setMinOverlapDutyCycles(*args):
        """
        setMinOverlapDutyCycles(self, minOverlapDutyCycles)
        setMinOverlapDutyCycles(self, py_x)
        """
        return _algorithms.SpatialPooler_setMinOverlapDutyCycles(*args)

    def getMinOverlapDutyCycles(*args):
        """
        getMinOverlapDutyCycles(self, minOverlapDutyCycles)
        getMinOverlapDutyCycles(self, py_x)
        """
        return _algorithms.SpatialPooler_getMinOverlapDutyCycles(*args)

    def setMinActiveDutyCycles(*args):
        """
        setMinActiveDutyCycles(self, minActiveDutyCycles)
        setMinActiveDutyCycles(self, py_x)
        """
        return _algorithms.SpatialPooler_setMinActiveDutyCycles(*args)

    def getMinActiveDutyCycles(*args):
        """
        getMinActiveDutyCycles(self, minActiveDutyCycles)
        getMinActiveDutyCycles(self, py_x)
        """
        return _algorithms.SpatialPooler_getMinActiveDutyCycles(*args)

    def setPotential(*args):
        """
        setPotential(self, column, potential)
        setPotential(self, column, py_x)
        """
        return _algorithms.SpatialPooler_setPotential(*args)

    def getPotential(*args):
        """
        getPotential(self, column, potential)
        getPotential(self, column, py_x)
        """
        return _algorithms.SpatialPooler_getPotential(*args)

    def setPermanence(*args):
        """
        setPermanence(self, column, permanence)
        setPermanence(self, column, py_x)
        """
        return _algorithms.SpatialPooler_setPermanence(*args)

    def getPermanence(*args):
        """
        getPermanence(self, column, permanence)
        getPermanence(self, column, py_x)
        """
        return _algorithms.SpatialPooler_getPermanence(*args)

    def getConnectedSynapses(*args):
        """
        getConnectedSynapses(self, column, connectedSynapses)
        getConnectedSynapses(self, column, py_x)
        """
        return _algorithms.SpatialPooler_getConnectedSynapses(*args)

    def getConnectedCounts(*args):
        """
        getConnectedCounts(self, connectedCounts)
        getConnectedCounts(self, py_x)
        """
        return _algorithms.SpatialPooler_getConnectedCounts(*args)

SpatialPooler_swigregister = _algorithms.SpatialPooler_swigregister
SpatialPooler_swigregister(SpatialPooler)

def SpatialPooler_updateDutyCyclesHelper_(*args, **kwargs):
  """SpatialPooler_updateDutyCyclesHelper_(dutyCycles, newValues, period)"""
  return _algorithms.SpatialPooler_updateDutyCyclesHelper_(*args, **kwargs)

class FlatSpatialPooler(SpatialPooler):
    """Proxy of C++ FlatSpatialPooler class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args, **kwargs): 
        """__init__(self) -> FlatSpatialPooler"""
        this = _algorithms.new_FlatSpatialPooler(*args, **kwargs)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _algorithms.delete_FlatSpatialPooler
    def getMinDistance(*args, **kwargs):
        """getMinDistance(self) -> Real"""
        return _algorithms.FlatSpatialPooler_getMinDistance(*args, **kwargs)

    def setMinDistance(*args, **kwargs):
        """setMinDistance(self, minDistance)"""
        return _algorithms.FlatSpatialPooler_setMinDistance(*args, **kwargs)

    def getRandomSP(*args, **kwargs):
        """getRandomSP(self) -> bool"""
        return _algorithms.FlatSpatialPooler_getRandomSP(*args, **kwargs)

    def setRandomSP(*args, **kwargs):
        """setRandomSP(self, randomSP)"""
        return _algorithms.FlatSpatialPooler_setRandomSP(*args, **kwargs)

    def addBonus_(*args, **kwargs):
        """addBonus_(self, vec, bonus, indices, replace)"""
        return _algorithms.FlatSpatialPooler_addBonus_(*args, **kwargs)

    def selectVirginColumns_(*args, **kwargs):
        """selectVirginColumns_(self, virgin)"""
        return _algorithms.FlatSpatialPooler_selectVirginColumns_(*args, **kwargs)

    def selectHighTierColumns_(*args, **kwargs):
        """selectHighTierColumns_(self, overlapsPct, highTier)"""
        return _algorithms.FlatSpatialPooler_selectHighTierColumns_(*args, **kwargs)

    def initializeFlat(*args, **kwargs):
        """
        initializeFlat(self, numInputs, numColumns, localAreaDensity=0, numActiveColumnsPerInhArea=10, 
            stimulusThreshold=0, synPermInactiveDec=0.01, 
            synPermActiveInc=0.1, 
            synPermConnected=0.1, minPctOverlapDutyCycles=0.001, 
            minPctActiveDutyCycles=0.001, dutyCyclePeriod=1000, 
            maxBoost=10.0, minDistance=0.0, 
            randomSP=False, seed=-1, spVerbosity=0)
        """
        return _algorithms.FlatSpatialPooler_initializeFlat(*args, **kwargs)

    import numpy

    def __init__(self,
                 inputShape=(32, 32),
                 inputBorder=8,
                 inputDensity=1.0,
                 coincidencesShape=(48, 48),
                 coincInputRadius=16,
                 coincInputPoolPct=1.0,
                 gaussianDist=False,
                 commonDistributions=False,
                 localAreaDensity=-1.0,
                 numActivePerInhArea=10.0,
                 stimulusThreshold=0,
                 synPermInactiveDec=0.01,
                 synPermActiveInc=0.1,
                 synPermActiveSharedDec=0.0,
                 synPermOrphanDec=0.0,
                 synPermConnected=0.10,
                 minPctDutyCycleBeforeInh=0.001,
                 minPctDutyCycleAfterInh=0.001,
                 dutyCyclePeriod=1000,
                 maxFiringBoost=10.0,
                 maxSSFiringBoost=2.0,
                 maxSynPermBoost=10.0,
                 minDistance=0.0,
                 cloneMap=None,
                 numCloneMasters=-1,
                 seed=-1,
                 spVerbosity=0,
                 printPeriodicStats=0,
                 testMode=False,
                 globalInhibition=False,
                 spReconstructionParam="unweighted_mean",
                 useHighTier=True,
                 randomSP=False,
              ):
      
      self.this = _ALGORITHMS.new_FlatSpatialPooler()
      _ALGORITHMS.FlatSpatialPooler_initializeFlat(
        self,
        numInputs=numpy.prod(inputShape),
        numColumns=numpy.prod(coincidencesShape),
        localAreaDensity=localAreaDensity,
        numActiveColumnsPerInhArea=numActivePerInhArea,
        stimulusThreshold=stimulusThreshold,
        synPermInactiveDec=synPermInactiveDec,
        synPermActiveInc=synPermActiveInc,
        synPermConnected=synPermConnected,
        minPctOverlapDutyCycles=minPctDutyCycleBeforeInh,
        minPctActiveDutyCycles=minPctDutyCycleAfterInh,
        dutyCyclePeriod=dutyCyclePeriod,
        maxBoost=maxFiringBoost,
        seed=seed,
        spVerbosity=spVerbosity
      )

FlatSpatialPooler_swigregister = _algorithms.FlatSpatialPooler_swigregister
FlatSpatialPooler_swigregister(FlatSpatialPooler)

class FastCLAClassifier(object):
    """Proxy of C++ FastCLAClassifier class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(self) -> FastCLAClassifier
        __init__(self, steps, alpha, actValueAlpha, verbosity) -> FastCLAClassifier
        """
        this = _algorithms.new_FastCLAClassifier(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _algorithms.delete_FastCLAClassifier
    def fastCompute(*args, **kwargs):
        """
        fastCompute(self, recordNum, patternNZ, bucketIdx, actValue, category, 
            learn, infer, result)
        """
        return _algorithms.FastCLAClassifier_fastCompute(*args, **kwargs)

    def version(*args, **kwargs):
        """version(self) -> UInt"""
        return _algorithms.FastCLAClassifier_version(*args, **kwargs)

    def persistentSize(*args, **kwargs):
        """persistentSize(self) -> UInt"""
        return _algorithms.FastCLAClassifier_persistentSize(*args, **kwargs)

    def save(*args, **kwargs):
        """save(self, outStream)"""
        return _algorithms.FastCLAClassifier_save(*args, **kwargs)

    def load(*args, **kwargs):
        """load(self, inStream)"""
        return _algorithms.FastCLAClassifier_load(*args, **kwargs)

    VERSION = 0

    def __init__(self, steps=(1,), alpha=0.001, actValueAlpha=0.3, verbosity=0):
      self.this = _ALGORITHMS.new_FastCLAClassifier(
          steps, alpha, actValueAlpha, verbosity)
      self.valueToCategory = {}
      self.version = FastCLAClassifier.VERSION

    def compute(self, recordNum, patternNZ, classification, learn, infer):
      isNone = False
      noneSentinel = 3.14159
      if type(classification["actValue"]) in (int, float):
        actValue = classification["actValue"]
        category = False
      elif classification["actValue"] is None:
        # Use the sentinel value so we know if it gets used in actualValues
        # returned.
        actValue = noneSentinel
        # Turn learning off this step.
        learn = False
        category = False
        # This does not get used when learning is disabled anyway.
        classification["bucketIdx"] = 0
        isNone = True
      else:
        actValue = int(classification["bucketIdx"])
        category = True
      result = self.convertedCompute(
          recordNum, patternNZ, int(classification["bucketIdx"]),
          actValue, category, learn, infer)
      if isNone:
        for i, v in enumerate(result["actualValues"]):
          if v - noneSentinel < 0.00001:
            result["actualValues"][i] = None
      arrayResult = dict((k, numpy.array(v)) if k != "actualValues" else (k, v)
                         for k, v in result.iteritems())
      if category:
        # Convert the bucketIdx back to the original value.
        for i in xrange(len(arrayResult["actualValues"])):
          arrayResult["actualValues"][i] = self.valueToCategory.get(int(
              arrayResult["actualValues"][i]), classification["actValue"])
        self.valueToCategory[actValue] = classification["actValue"]
      return arrayResult

    def __getstate__(self):
      # Save the local attributes but override the C++ classifier with the
      # string representation.
      d = dict(self.__dict__)
      d["this"] = self.getCState()
      return d

    def __setstate__(self, state):
      # Create an empty C++ classifier and populate it from the serialized
      # string.
      self.this = _ALGORITHMS.new_FastCLAClassifier()
      if isinstance(state, str):
        self.loadFromString(state)
        self.valueToCategory = {}
      else:
        assert state["version"] == 0
        self.loadFromString(state["this"])
        # Use the rest of the state to set local Python attributes.
        del state["this"]
        self.__dict__.update(state)

    def loadFromString(*args, **kwargs):
        """loadFromString(self, inString)"""
        return _algorithms.FastCLAClassifier_loadFromString(*args, **kwargs)

    def getCState(*args, **kwargs):
        """getCState(self) -> PyObject"""
        return _algorithms.FastCLAClassifier_getCState(*args, **kwargs)

    def convertedCompute(*args, **kwargs):
        """
        convertedCompute(self, recordNum, patternNZ, bucketIdx, actValue, category, 
            learn, infer) -> PyObject
        """
        return _algorithms.FastCLAClassifier_convertedCompute(*args, **kwargs)

FastCLAClassifier_swigregister = _algorithms.FastCLAClassifier_swigregister
FastCLAClassifier_swigregister(FastCLAClassifier)
Version = cvar.Version

import numpy



